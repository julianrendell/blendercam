
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>cam.utils &#8212; BlenderCAM 1.0.38 documentation</title>
  
  
  
  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
  <!-- 
    this give us a css class that will be invisible only if js is disabled 
  -->
  <noscript>
    <style>
      .pst-js-only { display: none !important; }

    </style>
  </noscript>
  
  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=26a4bc78f4c0ddb94549" rel="stylesheet" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/styles/sphinx-book-theme.css?v=a3416100" />
    <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=4ae1632d" />
  
  <!-- So that users can add custom icons -->
  <script src="../../_static/scripts/fontawesome.js?digest=26a4bc78f4c0ddb94549"></script>
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549" />

    <script src="../../_static/documentation_options.js?v=e842dffb"></script>
    <script src="../../_static/doctools.js?v=9bcbadda"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/scripts/sphinx-book-theme.js?v=887ef09a"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/cam/utils';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  <meta name="docsearch:version" content="" />
  </head>
  
  
  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">

  
  
  <div id="pst-skip-link" class="skip-link d-print-none"><a href="#main-content">Skip to main content</a></div>
  
  <div id="pst-scroll-pixel-helper"></div>
  
  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>Back to top</button>

  
  <dialog id="pst-search-dialog">
    
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         placeholder="Search..."
         aria-label="Search..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
  </dialog>

  <div class="pst-async-banner-revealer d-none">
  <aside id="bd-header-version-warning" class="d-none d-print-none" aria-label="Version warning"></aside>
</div>

  
    <header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
    </header>
  

  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">
      
      
      
        
      
      <dialog id="pst-primary-sidebar-modal"></dialog>
      <div id="pst-primary-sidebar" class="bd-sidebar-primary bd-sidebar">
        

  
  <div class="sidebar-header-items sidebar-primary__section">
    
    
    
    
  </div>
  
    <div class="sidebar-primary-items__start sidebar-primary__section">
        <div class="sidebar-primary-item">

  
    
  

<a class="navbar-brand logo" href="../../index.html">
  
  
  
  
  
    
    
      
    
    
    <img src="../../_static/logo_blendercam.png" class="logo__image only-light" alt="BlenderCAM 1.0.38 documentation - Home"/>
    <img src="../../_static/logo_blendercam.png" class="logo__image only-dark pst-js-only" alt="BlenderCAM 1.0.38 documentation - Home"/>
  
  
</a></div>
        <div class="sidebar-primary-item"><ul class="navbar-icon-links"
    aria-label="Icon Links">
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://github.com/pppalain/blendercam" title="GitHub" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-brands fa-square-github fa-lg" aria-hidden="true"></i>
            <span class="sr-only">GitHub</span></a>
        </li>
        <li class="nav-item">
          
          
          
          
          
          
          
          
          <a href="https://riot.im/app/#/room/#blendercam:matrix.org" title="Matrix" class="nav-link pst-navbar-icon" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><i class="fa-solid fa-comments fa-lg" aria-hidden="true"></i>
            <span class="sr-only">Matrix</span></a>
        </li>
</ul></div>
        <div class="sidebar-primary-item">

<button class="btn search-button-field search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
 <i class="fa-solid fa-magnifying-glass"></i>
 <span class="search-button__default-text">Search</span>
 <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
</button></div>
        <div class="sidebar-primary-item"><nav class="bd-links bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item navbar-nav active">
        <p aria-level="2" class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="nav bd-sidenav">
<li class="toctree-l1"><a class="reference internal" href="../../overview.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../styleguide.html">Style Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../testing.html">Test Suite</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../workflows.html">Workflows &amp; Actions</a></li>
<li class="toctree-l1 has-children"><a class="reference internal" href="../../autoapi/index.html">API Reference</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l2 has-children"><a class="reference internal" href="../../autoapi/cam/index.html">cam</a><details><summary><span class="toctree-toggle" role="presentation"><i class="fa-solid fa-chevron-down"></i></span></summary><ul>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/autoupdate/index.html">cam.autoupdate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/basrelief/index.html">cam.basrelief</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/bridges/index.html">cam.bridges</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/cam_chunk/index.html">cam.cam_chunk</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/cam_operation/index.html">cam.cam_operation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/chain/index.html">cam.chain</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/collision/index.html">cam.collision</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/constants/index.html">cam.constants</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/curvecamcreate/index.html">cam.curvecamcreate</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/curvecamequation/index.html">cam.curvecamequation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/curvecamtools/index.html">cam.curvecamtools</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/engine/index.html">cam.engine</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/exception/index.html">cam.exception</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/gcodeimportparser/index.html">cam.gcodeimportparser</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/gcodepath/index.html">cam.gcodepath</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/image_utils/index.html">cam.image_utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/involute_gear/index.html">cam.involute_gear</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/joinery/index.html">cam.joinery</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/machine_settings/index.html">cam.machine_settings</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/numba_wrapper/index.html">cam.numba_wrapper</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/ops/index.html">cam.ops</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/pack/index.html">cam.pack</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/parametric/index.html">cam.parametric</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/pattern/index.html">cam.pattern</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/polygon_utils_cam/index.html">cam.polygon_utils_cam</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/preset_managers/index.html">cam.preset_managers</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/puzzle_joinery/index.html">cam.puzzle_joinery</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/simple/index.html">cam.simple</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/simulation/index.html">cam.simulation</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/slice/index.html">cam.slice</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/strategy/index.html">cam.strategy</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/testing/index.html">cam.testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/ui/index.html">cam.ui</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/utils/index.html">cam.utils</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/version/index.html">cam.version</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../autoapi/cam/voronoi/index.html">cam.voronoi</a></li>
</ul>
</details></li>
</ul>
</details></li>
</ul>

    </div>
</nav></div>
    </div>
  
  
  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>
  
  <div id="rtd-footer-container"></div>


      </div>
      
      <main id="main-content" class="bd-main" role="main">
        
        

<div class="sbt-scroll-pixel-helper"></div>

          <div class="bd-content">
            <div class="bd-article-container">
              
              <div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
  
    <div class="header-article-items__start">
      
        <div class="header-article-item"><button class="sidebar-toggle primary-toggle btn btn-sm" title="Toggle primary sidebar" data-bs-placement="bottom" data-bs-toggle="tooltip">
  <span class="fa-solid fa-bars"></span>
</button></div>
      
    </div>
  
  
    <div class="header-article-items__end">
      
        <div class="header-article-item">

<div class="article-header-buttons">



<button onclick="toggleFullScreen()"
  class="btn btn-sm btn-fullscreen-button"
  title="Fullscreen mode"
  data-bs-placement="bottom" data-bs-toggle="tooltip"
>
  

<span class="btn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>



<button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button pst-js-only" aria-label="Color mode" data-bs-title="Color mode"  data-bs-placement="bottom" data-bs-toggle="tooltip">
  <i class="theme-switch fa-solid fa-sun                fa-lg" data-mode="light" title="Light"></i>
  <i class="theme-switch fa-solid fa-moon               fa-lg" data-mode="dark"  title="Dark"></i>
  <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"  title="System Settings"></i>
</button>


<button class="btn btn-sm pst-navbar-icon search-button search-button__button pst-js-only" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass fa-lg"></i>
</button>

</div></div>
      
    </div>
  
</div>
</div>
              
              

<div id="jb-print-docs-body" class="onlyprint">
    <h1></h1>
    <!-- Table of contents -->
    <div id="print-main-content">
        <div id="jb-print-toc">
            
        </div>
    </div>
</div>

              
                
<div id="searchbox"></div>
                <article class="bd-article">
                  
  <h1>Source code for cam.utils</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;BlenderCAM &#39;utils.py&#39; Â© 2012 Vilem Novak</span>

<span class="sd">Main functionality of BlenderCAM.</span>
<span class="sd">The functions here are called with operators defined in &#39;ops.py&#39;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">ceil</span><span class="p">,</span>
    <span class="n">pi</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="kn">import</span> <span class="nn">numpy</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">ops</span> <span class="k">as</span> <span class="n">sops</span>
<span class="kn">from</span> <span class="nn">shapely</span> <span class="kn">import</span> <span class="n">geometry</span> <span class="k">as</span> <span class="n">sgeometry</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">polygon</span> <span class="k">as</span> <span class="n">spolygon</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">MultiPolygon</span>

<span class="kn">import</span> <span class="nn">bpy</span>
<span class="kn">from</span> <span class="nn">bpy.app.handlers</span> <span class="kn">import</span> <span class="n">persistent</span>
<span class="kn">from</span> <span class="nn">bpy_extras</span> <span class="kn">import</span> <span class="n">object_utils</span>
<span class="kn">from</span> <span class="nn">mathutils</span> <span class="kn">import</span> <span class="n">Euler</span><span class="p">,</span> <span class="n">Vector</span>

<span class="kn">from</span> <span class="nn">.async_op</span> <span class="kn">import</span> <span class="n">progress_async</span>
<span class="kn">from</span> <span class="nn">.cam_chunk</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">curveToChunks</span><span class="p">,</span>
    <span class="n">parentChild</span><span class="p">,</span>
    <span class="n">camPathChunk</span><span class="p">,</span>
    <span class="n">camPathChunkBuilder</span><span class="p">,</span>
    <span class="n">parentChildDist</span><span class="p">,</span>
    <span class="n">chunksToShapely</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.collision</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">getSampleBullet</span><span class="p">,</span>
    <span class="n">getSampleBulletNAxis</span><span class="p">,</span>
    <span class="n">prepareBulletCollision</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.exception</span> <span class="kn">import</span> <span class="n">CamException</span>
<span class="kn">from</span> <span class="nn">.image_utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">imageToChunks</span><span class="p">,</span>
    <span class="n">getSampleImage</span><span class="p">,</span>
    <span class="n">renderSampleImage</span><span class="p">,</span>
    <span class="n">prepareArea</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.opencamlib.opencamlib</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">oclSample</span><span class="p">,</span>
    <span class="n">oclResampleChunks</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">.polygon_utils_cam</span> <span class="kn">import</span> <span class="n">shapelyToCurve</span><span class="p">,</span> <span class="n">shapelyToMultipolygon</span>
<span class="kn">from</span> <span class="nn">.simple</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">activate</span><span class="p">,</span>
    <span class="n">progress</span><span class="p">,</span>
    <span class="n">select_multiple</span><span class="p">,</span>
    <span class="n">delob</span><span class="p">,</span>
    <span class="n">timingadd</span><span class="p">,</span>
    <span class="n">timinginit</span><span class="p">,</span>
    <span class="n">timingstart</span><span class="p">,</span>
    <span class="n">tuple_add</span><span class="p">,</span>
    <span class="n">tuple_mul</span><span class="p">,</span>
    <span class="n">tuple_sub</span><span class="p">,</span>
    <span class="n">isVerticalLimit</span><span class="p">,</span>
    <span class="n">getCachePath</span>
<span class="p">)</span>

<span class="c1"># from shapely.geometry import * not possible until Polygon libs gets out finally..</span>
<div class="viewcode-block" id="SHAPELY">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.SHAPELY">[docs]</a>
<span class="n">SHAPELY</span> <span class="o">=</span> <span class="kc">True</span></div>



<span class="c1"># Import OpencamLib</span>
<span class="c1"># Return available OpenCamLib version on success, None otherwise</span>
<div class="viewcode-block" id="opencamlib_version">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.opencamlib_version">[docs]</a>
<span class="k">def</span> <span class="nf">opencamlib_version</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the version of the OpenCamLib library.</span>

<span class="sd">    This function attempts to import the OpenCamLib library and returns its</span>
<span class="sd">    version. If the library is not available, it will return None. The</span>
<span class="sd">    function first tries to import the library using the name &#39;ocl&#39;, and if</span>
<span class="sd">    that fails, it attempts to import it using &#39;opencamlib&#39; as an alias. If</span>
<span class="sd">    both imports fail, it returns None.</span>

<span class="sd">    Returns:</span>
<span class="sd">        str or None: The version of OpenCamLib if available, None otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">ocl</span>
    <span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">opencamlib</span> <span class="k">as</span> <span class="nn">ocl</span>
        <span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">return</span>
    <span class="k">return</span> <span class="n">ocl</span><span class="o">.</span><span class="n">version</span><span class="p">()</span></div>



<div class="viewcode-block" id="positionObject">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.positionObject">[docs]</a>
<span class="k">def</span> <span class="nf">positionObject</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Position an object based on specified operation parameters.</span>

<span class="sd">    This function adjusts the location of a Blender object according to the</span>
<span class="sd">    provided operation settings. It calculates the bounding box of the</span>
<span class="sd">    object in world space and modifies its position based on the material&#39;s</span>
<span class="sd">    center settings and specified z-positioning (BELOW, ABOVE, or CENTERED).</span>
<span class="sd">    The function also applies transformations to the object if it is not of</span>
<span class="sd">    type &#39;CURVE&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        operation (OperationType): An object containing parameters for positioning,</span>
<span class="sd">            including object_name, use_modifiers, and material</span>
<span class="sd">            settings.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">operation</span><span class="o">.</span><span class="n">object_name</span><span class="p">]</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">origin_set</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ORIGIN_GEOMETRY&#39;</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="s1">&#39;BOUNDS&#39;</span><span class="p">)</span>
    <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>

    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">getBoundsWorldspace</span><span class="p">([</span><span class="n">ob</span><span class="p">],</span> <span class="n">operation</span><span class="o">.</span><span class="n">use_modifiers</span><span class="p">)</span>
    <span class="n">totx</span> <span class="o">=</span> <span class="n">maxx</span> <span class="o">-</span> <span class="n">minx</span>
    <span class="n">toty</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">-</span> <span class="n">miny</span>
    <span class="n">totz</span> <span class="o">=</span> <span class="n">maxz</span> <span class="o">-</span> <span class="n">minz</span>
    <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">center_x</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">minx</span> <span class="o">+</span> <span class="n">totx</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">minx</span>

    <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">center_y</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">miny</span> <span class="o">+</span> <span class="n">toty</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">miny</span>

    <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">z_position</span> <span class="o">==</span> <span class="s1">&#39;BELOW&#39;</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span> <span class="o">-=</span> <span class="n">maxz</span>
    <span class="k">elif</span> <span class="n">operation</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">z_position</span> <span class="o">==</span> <span class="s1">&#39;ABOVE&#39;</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span> <span class="o">-=</span> <span class="n">minz</span>
    <span class="k">elif</span> <span class="n">operation</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">z_position</span> <span class="o">==</span> <span class="s1">&#39;CENTERED&#39;</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span> <span class="o">-=</span> <span class="n">minz</span> <span class="o">+</span> <span class="n">totz</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="s1">&#39;CURVE&#39;</span><span class="p">:</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">transform_apply</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>

    <span class="c1"># addMaterialAreaObject()</span>


<div class="viewcode-block" id="getBoundsWorldspace">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getBoundsWorldspace">[docs]</a>
<span class="k">def</span> <span class="nf">getBoundsWorldspace</span><span class="p">(</span><span class="n">obs</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the bounding box of a list of objects in world space.</span>

<span class="sd">    This function calculates the minimum and maximum coordinates that</span>
<span class="sd">    encompass all the specified objects in the 3D world space. It iterates</span>
<span class="sd">    through each object, taking into account their transformations and</span>
<span class="sd">    modifiers if specified. The function supports different object types,</span>
<span class="sd">    including meshes and fonts, and handles the conversion of font objects</span>
<span class="sd">    to mesh format for accurate bounding box calculations.</span>

<span class="sd">    Args:</span>
<span class="sd">        obs (list): A list of Blender objects to calculate bounds for.</span>
<span class="sd">        use_modifiers (bool): If True, apply modifiers to the objects</span>
<span class="sd">            before calculating bounds. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the minimum and maximum coordinates</span>
<span class="sd">            in the format (minx, miny, minz, maxx, maxy, maxz).</span>

<span class="sd">    Raises:</span>
<span class="sd">        CamException: If an object type does not support CAM operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># progress(&#39;getting bounds of object(s)&#39;)</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>

    <span class="n">maxx</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">maxz</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000000</span>
    <span class="n">minx</span> <span class="o">=</span> <span class="n">miny</span> <span class="o">=</span> <span class="n">minz</span> <span class="o">=</span> <span class="mi">10000000</span>
    <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">obs</span><span class="p">:</span>
        <span class="c1"># bb=ob.bound_box</span>
        <span class="n">mw</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">matrix_world</span>
        <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;MESH&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">use_modifiers</span><span class="p">:</span>
                <span class="n">depsgraph</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">evaluated_depsgraph_get</span><span class="p">()</span>
                <span class="n">mesh_owner</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">evaluated_get</span><span class="p">(</span><span class="n">depsgraph</span><span class="p">)</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">mesh_owner</span><span class="o">.</span><span class="n">to_mesh</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mesh</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">data</span>

            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">co</span>
                <span class="n">worldCoord</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">Vector</span><span class="p">((</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">use_modifiers</span><span class="p">:</span>
                <span class="n">mesh_owner</span><span class="o">.</span><span class="n">to_mesh_clear</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s2">&quot;FONT&quot;</span><span class="p">:</span>
            <span class="n">activate</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
            <span class="n">co</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">parent_clear</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;CLEAR_KEEP_TRANSFORM&#39;</span><span class="p">)</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="s1">&#39;MESH&#39;</span><span class="p">,</span> <span class="n">keep_original</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">co</span><span class="o">.</span><span class="n">data</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">mesh</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
                <span class="n">coord</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">co</span>
                <span class="n">worldCoord</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">Vector</span><span class="p">((</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">outliner</span><span class="o">.</span><span class="n">orphans_purge</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;splines&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">CamException</span><span class="p">(</span><span class="s2">&quot;Can&#39;t do CAM operation on the selected object type&quot;</span><span class="p">)</span>
            <span class="c1"># for coord in bb:</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">splines</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">bezier_points</span><span class="p">:</span>
                    <span class="n">coord</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">co</span>
                    <span class="c1"># this can work badly with some imported curves, don&#39;t know why...</span>
                    <span class="c1"># worldCoord = mw * Vector((coord[0]/ob.scale.x, coord[1]/ob.scale.y, coord[2]/ob.scale.z))</span>
                    <span class="n">worldCoord</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">Vector</span><span class="p">((</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">c</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
                    <span class="n">coord</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">co</span>
                    <span class="c1"># this can work badly with some imported curves, don&#39;t know why...</span>
                    <span class="c1"># worldCoord = mw * Vector((coord[0]/ob.scale.x, coord[1]/ob.scale.y, coord[2]/ob.scale.z))</span>
                    <span class="n">worldCoord</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">Vector</span><span class="p">((</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
                    <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                    <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                    <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="c1"># progress(time.time()-t)</span>
    <span class="k">return</span> <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span></div>



<div class="viewcode-block" id="getSplineBounds">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getSplineBounds">[docs]</a>
<span class="k">def</span> <span class="nf">getSplineBounds</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">curve</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the bounding box of a spline object.</span>

<span class="sd">    This function calculates the minimum and maximum coordinates (x, y, z)</span>
<span class="sd">    of the given spline object by iterating through its bezier points and</span>
<span class="sd">    regular points. It transforms the local coordinates to world coordinates</span>
<span class="sd">    using the object&#39;s transformation matrix. The resulting bounds can be</span>
<span class="sd">    used for various purposes, such as collision detection or rendering.</span>

<span class="sd">    Args:</span>
<span class="sd">        ob (Object): The object containing the spline whose bounds are to be calculated.</span>
<span class="sd">        curve (Curve): The curve object that contains the bezier points and regular points.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the minimum and maximum coordinates in the</span>
<span class="sd">        format (minx, miny, minz, maxx, maxy, maxz).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># progress(&#39;getting bounds of object(s)&#39;)</span>
    <span class="n">maxx</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">maxz</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000000</span>
    <span class="n">minx</span> <span class="o">=</span> <span class="n">miny</span> <span class="o">=</span> <span class="n">minz</span> <span class="o">=</span> <span class="mi">10000000</span>
    <span class="n">mw</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">matrix_world</span>

    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">curve</span><span class="o">.</span><span class="n">bezier_points</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">co</span>
        <span class="c1"># this can work badly with some imported curves, don&#39;t know why...</span>
        <span class="c1"># worldCoord = mw * Vector((coord[0]/ob.scale.x, coord[1]/ob.scale.y, coord[2]/ob.scale.z))</span>
        <span class="n">worldCoord</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">Vector</span><span class="p">((</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">curve</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
        <span class="n">coord</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">co</span>
        <span class="c1"># this can work badly with some imported curves, don&#39;t know why...</span>
        <span class="c1"># worldCoord = mw * Vector((coord[0]/ob.scale.x, coord[1]/ob.scale.y, coord[2]/ob.scale.z))</span>
        <span class="n">worldCoord</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">Vector</span><span class="p">((</span><span class="n">coord</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">coord</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">worldCoord</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="c1"># progress(time.time()-t)</span>
    <span class="k">return</span> <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span></div>



<div class="viewcode-block" id="getOperationSources">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getOperationSources">[docs]</a>
<span class="k">def</span> <span class="nf">getOperationSources</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get operation sources based on the geometry source type.</span>

<span class="sd">    This function retrieves and sets the operation sources for a given</span>
<span class="sd">    object based on its geometry source type. It handles three types of</span>
<span class="sd">    geometry sources: &#39;OBJECT&#39;, &#39;COLLECTION&#39;, and &#39;IMAGE&#39;. For &#39;OBJECT&#39;, it</span>
<span class="sd">    selects the specified object and applies rotations if enabled. For</span>
<span class="sd">    &#39;COLLECTION&#39;, it retrieves all objects within the specified collection.</span>
<span class="sd">    For &#39;IMAGE&#39;, it sets a specific optimization flag. Additionally, it</span>
<span class="sd">    determines whether the objects are curves or meshes based on the</span>
<span class="sd">    geometry source.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (Object): An object containing properties such as geometry_source,</span>
<span class="sd">            object_name, collection_name, rotation_A, rotation_B,</span>
<span class="sd">            enable_A, enable_B, old_rotation_A, old_rotation_B,</span>
<span class="sd">            A_along_x, and optimisation.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function does not return a value but modifies the</span>
<span class="sd">            properties of the input object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;OBJECT&#39;</span><span class="p">:</span>
        <span class="c1"># bpy.ops.object.select_all(action=&#39;DESELECT&#39;)</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">object_name</span><span class="p">]</span>
        <span class="n">o</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="n">ob</span><span class="p">]</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_B</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_A</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">old_rotation_A</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">old_rotation_B</span> <span class="o">!=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_B</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">old_rotation_A</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span>
                <span class="n">o</span><span class="o">.</span><span class="n">old_rotation_B</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_B</span>
                <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">object_name</span><span class="p">]</span>
                <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">A_along_x</span><span class="p">:</span>  <span class="c1"># A parallel with X</span>
                    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_A</span><span class="p">:</span>
                        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span>
                    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_B</span><span class="p">:</span>
                        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_B</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># A parallel with Y</span>
                    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_A</span><span class="p">:</span>
                        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span>
                    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_B</span><span class="p">:</span>
                        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_B</span>

    <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;COLLECTION&#39;</span><span class="p">:</span>
        <span class="n">collection</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">collection_name</span><span class="p">]</span>
        <span class="n">o</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="n">collection</span><span class="o">.</span><span class="n">objects</span>
    <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;IMAGE&#39;</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;OBJECT&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;COLLECTION&#39;</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">onlycurves</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;MESH&#39;</span><span class="p">:</span>
                <span class="n">o</span><span class="o">.</span><span class="n">onlycurves</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">onlycurves</span> <span class="o">=</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="getBounds">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getBounds">[docs]</a>
<span class="k">def</span> <span class="nf">getBounds</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the bounding box for a given object.</span>

<span class="sd">    This function determines the minimum and maximum coordinates of an</span>
<span class="sd">    object&#39;s bounding box based on its geometry source. It handles different</span>
<span class="sd">    geometry types such as OBJECT, COLLECTION, and CURVE. The function also</span>
<span class="sd">    considers material properties and image cropping if applicable. The</span>
<span class="sd">    bounding box is adjusted according to the object&#39;s material settings and</span>
<span class="sd">    the optimization parameters defined in the object.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing geometry and material properties, as well as</span>
<span class="sd">            optimization settings.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function modifies the input object in place and does not return a</span>
<span class="sd">            value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># print(&#39;kolikrat sem rpijde&#39;)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;OBJECT&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;COLLECTION&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;CURVE&#39;</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Valid Geometry&quot;</span><span class="p">)</span>
        <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">getBoundsWorldspace</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">use_modifiers</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">minz_from</span> <span class="o">==</span> <span class="s1">&#39;OBJECT&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">minz</span> <span class="o">==</span> <span class="mi">10000000</span><span class="p">:</span>
                <span class="n">minz</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Minz from Object:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">minz</span><span class="p">))</span>
            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">minz</span>
            <span class="n">o</span><span class="o">.</span><span class="n">minz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">minz</span>  <span class="c1"># max(bb[0][2]+l.z,o.minz)#</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not Minz from Object&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">estimate_from_model</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Estimate Material from Model&quot;</span><span class="p">)</span>

            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">minx</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">radius_around_model</span>
            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">miny</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">radius_around_model</span>
            <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">maxz</span><span class="p">,</span> <span class="n">maxz</span><span class="p">)</span>

            <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">maxx</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">radius_around_model</span>
            <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">radius_around_model</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Not Material from Model&quot;</span><span class="p">)</span>
            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">x</span>
            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">y</span>
            <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">z</span>
            <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">x</span>
            <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">size</span><span class="o">.</span><span class="n">y</span>
            <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">z</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">images</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">source_image_name</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_crop</span><span class="p">:</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_crop_start_x</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_crop_end_x</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_crop_start_y</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
            <span class="n">ey</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_crop_end_y</span> <span class="o">/</span> <span class="mi">100</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ex</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">sy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ey</span> <span class="o">=</span> <span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_size_x</span> <span class="o">/</span> <span class="n">i</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_offset</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">sx</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>
        <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_offset</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">ex</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>
        <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_offset</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">sy</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>
        <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_offset</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">ey</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>
        <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_offset</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">minz</span>
        <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_offset</span><span class="o">.</span><span class="n">z</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_machine</span>
    <span class="c1"># make sure this message only shows once and goes away once fixed</span>
    <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">warnings</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;Operation Exceeds Your Machine Limits</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">working_area</span><span class="o">.</span><span class="n">x</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">working_area</span><span class="o">.</span><span class="n">y</span> \
            <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span> <span class="o">&gt;</span> <span class="n">m</span><span class="o">.</span><span class="n">working_area</span><span class="o">.</span><span class="n">z</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">warnings</span> <span class="o">+=</span> <span class="s1">&#39;Operation Exceeds Your Machine Limits</span><span class="se">\n</span><span class="s1">&#39;</span></div>



<div class="viewcode-block" id="getBoundsMultiple">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getBoundsMultiple">[docs]</a>
<span class="k">def</span> <span class="nf">getBoundsMultiple</span><span class="p">(</span><span class="n">operations</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gets bounds of multiple operations for simulations or rest milling.</span>

<span class="sd">    This function iterates through a list of operations to determine the</span>
<span class="sd">    minimum and maximum bounds in three-dimensional space (x, y, z). It</span>
<span class="sd">    initializes the bounds to extreme values and updates them based on the</span>
<span class="sd">    bounds of each operation. The function is primarily intended for use in</span>
<span class="sd">    simulations or rest milling processes, although it is noted that the</span>
<span class="sd">    implementation may not be optimal.</span>

<span class="sd">    Args:</span>
<span class="sd">        operations (list): A list of operation objects, each containing</span>
<span class="sd">            &#39;min&#39; and &#39;max&#39; attributes with &#39;x&#39;, &#39;y&#39;,</span>
<span class="sd">            and &#39;z&#39; coordinates.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing the minimum and maximum bounds in the</span>
<span class="sd">            order (minx, miny, minz, maxx, maxy, maxz).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">maxx</span> <span class="o">=</span> <span class="n">maxy</span> <span class="o">=</span> <span class="n">maxz</span> <span class="o">=</span> <span class="o">-</span><span class="mi">10000000</span>
    <span class="n">minx</span> <span class="o">=</span> <span class="n">miny</span> <span class="o">=</span> <span class="n">minz</span> <span class="o">=</span> <span class="mi">10000000</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">operations</span><span class="p">:</span>
        <span class="n">getBounds</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">maxx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxx</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">maxy</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxy</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">maxz</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxz</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
        <span class="n">minx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minx</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
        <span class="n">miny</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">miny</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">minz</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">minz</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span></div>



<div class="viewcode-block" id="samplePathLow">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.samplePathLow">[docs]</a>
<span class="k">def</span> <span class="nf">samplePathLow</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">ch1</span><span class="p">,</span> <span class="n">ch2</span><span class="p">,</span> <span class="n">dosample</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a sample path between two channels.</span>

<span class="sd">    This function computes a series of points that form a path between two</span>
<span class="sd">    given channels. It calculates the direction vector from the end of the</span>
<span class="sd">    first channel to the start of the second channel and generates points</span>
<span class="sd">    along this vector up to a specified distance. If sampling is enabled, it</span>
<span class="sd">    modifies the z-coordinate of the generated points based on the cutter</span>
<span class="sd">    shape or image sampling, ensuring that the path accounts for any</span>
<span class="sd">    obstacles or features in the environment.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: An object containing optimization parameters and properties related to</span>
<span class="sd">            the path generation.</span>
<span class="sd">        ch1: The first channel object, which provides a point for the starting</span>
<span class="sd">            location of the path.</span>
<span class="sd">        ch2: The second channel object, which provides a point for the ending</span>
<span class="sd">            location of the path.</span>
<span class="sd">        dosample (bool): A flag indicating whether to perform sampling along the generated path.</span>

<span class="sd">    Returns:</span>
<span class="sd">        camPathChunk: An object representing the generated path points.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ch1</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">ch2</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="n">v</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">v</span><span class="o">.</span><span class="n">length</span>
    <span class="n">v</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>

    <span class="n">vref</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">bpath_points</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">vref</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">vref</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">dist_along_paths</span> <span class="o">*</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">vref</span><span class="o">.</span><span class="n">length</span> <span class="o">&lt;</span> <span class="n">d</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="n">vref</span>
            <span class="n">bpath_points</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">z</span><span class="p">])</span>
    <span class="c1"># print(&#39;between path&#39;)</span>
    <span class="c1"># print(len(bpath))</span>
    <span class="n">pixsize</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>
    <span class="k">if</span> <span class="n">dosample</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span><span class="p">:</span>
                    <span class="n">prepareBulletCollision</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">cutterdepth</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bpath_points</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">getSampleBullet</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cutterdepth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">minz</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">bpath_points</span><span class="p">:</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">+</span> <span class="n">pixsize</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># -m</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">+</span> <span class="n">pixsize</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># -m</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">getSampleImage</span><span class="p">((</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">offset_image</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">minz</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">skin</span>
                    <span class="k">if</span> <span class="n">z</span> <span class="o">&gt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                        <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>
    <span class="k">return</span> <span class="n">camPathChunk</span><span class="p">(</span><span class="n">bpath_points</span><span class="p">)</span></div>



<span class="c1"># def threadedSampling():#not really possible at all without running more blenders for same operation :( python!</span>
<span class="c1"># samples in both modes now - image and bullet collision too.</span>
<div class="viewcode-block" id="sampleChunks">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.sampleChunks">[docs]</a>
<span class="k">async</span> <span class="k">def</span> <span class="nf">sampleChunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pathSamples</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample chunks of paths based on the provided parameters.</span>

<span class="sd">    This function processes the given path samples and layers to generate</span>
<span class="sd">    chunks of points that represent the sampled paths. It takes into account</span>
<span class="sd">    various optimization settings and strategies to determine how the points</span>
<span class="sd">    are sampled and organized into layers. The function handles different</span>
<span class="sd">    scenarios based on the object&#39;s properties and the specified layers,</span>
<span class="sd">    ensuring that the resulting chunks are correctly structured for further</span>
<span class="sd">    processing.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing various properties and settings</span>
<span class="sd">            related to the sampling process.</span>
<span class="sd">        pathSamples (list): A list of path samples to be processed.</span>
<span class="sd">        layers (list): A list of layers defining the z-coordinate ranges</span>
<span class="sd">            for sampling.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of sampled chunks, each containing points that represent</span>
<span class="sd">            the sampled paths.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>
    <span class="n">getAmbient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>  <span class="c1"># prepare collision world</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">oclSample</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pathSamples</span><span class="p">)</span>
            <span class="n">cutterdepth</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span><span class="p">:</span>
                <span class="n">prepareBulletCollision</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

                <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print (o.ambient)</span>
            <span class="n">cutter</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span>
            <span class="n">cutterdepth</span> <span class="o">=</span> <span class="n">cutter</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># or prepare offset image, but not in some strategies.</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;WATERLINE&#39;</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">prepareArea</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

        <span class="n">pixsize</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span>

        <span class="n">coordoffset</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">borderwidth</span> <span class="o">+</span> <span class="n">pixsize</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># -m</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">pixsize</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">res</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="c1"># print(&#39;sampling paths&#39;)</span>

    <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total length of all chunks, to estimate sampling time.</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="n">ch</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
    <span class="n">layerchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">minz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">minz</span> <span class="o">-</span> <span class="mf">0.000001</span>  <span class="c1"># correction for image method problems</span>
    <span class="n">layeractivechunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
        <span class="n">layerchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">layeractivechunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camPathChunkBuilder</span><span class="p">([]))</span>
        <span class="n">lastrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>

    <span class="n">zinvert</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">inverse</span><span class="p">:</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">object_name</span><span class="p">]</span>
        <span class="n">zinvert</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span> <span class="o">+</span> <span class="n">maxz</span>  <span class="c1"># ob.bound_box[6][2]</span>

    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Total Sample Points </span><span class="si">{</span><span class="n">totlen</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">last_percent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># timing for optimisation</span>
    <span class="n">samplingtime</span> <span class="o">=</span> <span class="n">timinginit</span><span class="p">()</span>
    <span class="n">sortingtime</span> <span class="o">=</span> <span class="n">timinginit</span><span class="p">()</span>
    <span class="n">totaltime</span> <span class="o">=</span> <span class="n">timinginit</span><span class="p">()</span>
    <span class="n">timingstart</span><span class="p">(</span><span class="n">totaltime</span><span class="p">)</span>
    <span class="n">lastz</span> <span class="o">=</span> <span class="n">minz</span>
    <span class="k">for</span> <span class="n">patternchunk</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="n">thisrunchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">thisrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">lastlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">currentlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lastsample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># threads_count=4</span>

        <span class="c1"># for t in range(0,threads):</span>
        <span class="n">our_points</span> <span class="o">=</span> <span class="n">patternchunk</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">()</span>
        <span class="n">ambient_contains</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">ambient</span><span class="p">,</span> <span class="n">shapely</span><span class="o">.</span><span class="n">points</span><span class="p">(</span><span class="n">our_points</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">in_ambient</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">our_points</span><span class="p">,</span> <span class="n">ambient_contains</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;WATERLINE&#39;</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">totlen</span><span class="p">)</span> <span class="o">!=</span> <span class="n">last_percent</span><span class="p">:</span>
                <span class="n">last_percent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">totlen</span><span class="p">)</span>
                <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s1">&#39;sampling paths &#39;</span><span class="p">,</span> <span class="n">last_percent</span><span class="p">)</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">in_ambient</span><span class="p">:</span>
                <span class="n">newsample</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">minz</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">minz</span>
                    <span class="n">newsample</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>
                <span class="c1"># ampling</span>
                <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span><span class="p">:</span>

                    <span class="k">if</span> <span class="n">lastsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># this is an optimalization,</span>
                        <span class="c1"># search only for near depths to the last sample. Saves about 30% of sampling time.</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">getSampleBullet</span><span class="p">(</span><span class="n">cutter</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                                            <span class="n">lastsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">dist_along_paths</span><span class="p">)</span>  <span class="c1"># first try to the last sample</span>
                        <span class="k">if</span> <span class="n">z</span> <span class="o">&lt;</span> <span class="n">minz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">z</span> <span class="o">=</span> <span class="n">getSampleBullet</span><span class="p">(</span><span class="n">cutter</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">,</span>
                                                <span class="n">lastsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">o</span><span class="o">.</span><span class="n">dist_along_paths</span><span class="p">,</span> <span class="n">minz</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">z</span> <span class="o">=</span> <span class="n">getSampleBullet</span><span class="p">(</span><span class="n">cutter</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">minz</span><span class="p">)</span>

                <span class="c1"># print(z)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">timingstart</span><span class="p">(</span><span class="n">samplingtime</span><span class="p">)</span>
                    <span class="n">xs</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">minx</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">coordoffset</span>
                    <span class="n">ys</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">miny</span><span class="p">)</span> <span class="o">/</span> <span class="n">pixsize</span> <span class="o">+</span> <span class="n">coordoffset</span>
                    <span class="n">timingadd</span><span class="p">(</span><span class="n">samplingtime</span><span class="p">)</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">getSampleImage</span><span class="p">((</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">),</span> <span class="n">o</span><span class="o">.</span><span class="n">offset_image</span><span class="p">,</span> <span class="n">minz</span><span class="p">)</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">skin</span>

                <span class="c1">################################</span>
                <span class="c1"># handling samples</span>
                <span class="c1">############################################</span>

                <span class="k">if</span> <span class="n">minz</span> <span class="o">&gt;</span> <span class="n">z</span><span class="p">:</span>
                    <span class="n">z</span> <span class="o">=</span> <span class="n">minz</span>
                <span class="n">newsample</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                <span class="n">terminatechunk</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">lastlayer</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># rather the last sample here ? has to be set to None,</span>
                    <span class="c1"># since sometimes lastsample vs lastlayer didn&#39;t fit and did ugly ugly stuff....</span>
                    <span class="k">if</span> <span class="n">lastsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">i2</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                            <span class="k">if</span> <span class="n">l2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">lastsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">l2</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                                <span class="n">lastlayer</span> <span class="o">=</span> <span class="n">i2</span>

                    <span class="n">currentlayer</span> <span class="o">=</span> <span class="n">i</span>
                    <span class="c1"># and lastsample[2]!=newsample[2]:</span>
                    <span class="k">if</span> <span class="n">lastlayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lastlayer</span> <span class="o">!=</span> <span class="n">currentlayer</span><span class="p">:</span>
                        <span class="c1"># #sampling for sorted paths in layers- to go to the border of the sampled layer at least...</span>
                        <span class="c1"># there was a bug here, but should be fixed.</span>
                        <span class="k">if</span> <span class="n">currentlayer</span> <span class="o">&lt;</span> <span class="n">lastlayer</span><span class="p">:</span>
                            <span class="n">growing</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">currentlayer</span><span class="p">,</span> <span class="n">lastlayer</span><span class="p">)</span>
                            <span class="n">spliti</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">lastlayer</span><span class="p">,</span> <span class="n">currentlayer</span><span class="p">)</span>
                            <span class="n">growing</span> <span class="o">=</span> <span class="kc">False</span>
                            <span class="n">spliti</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="c1"># print(r)</span>
                        <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                            <span class="n">splitz</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">ls</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                            <span class="c1"># print(ls)</span>

                            <span class="n">v1</span> <span class="o">=</span> <span class="n">lastsample</span>
                            <span class="n">v2</span> <span class="o">=</span> <span class="n">newsample</span>
                            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">protect_vertical</span><span class="p">:</span>
                                <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="o">=</span> <span class="n">isVerticalLimit</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">protect_vertical_limit</span><span class="p">)</span>
                            <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">v1</span><span class="p">)</span>
                            <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">v2</span><span class="p">)</span>
                            <span class="c1"># print(v1,v2)</span>
                            <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">splitz</span> <span class="o">-</span> <span class="n">v1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">v2</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">v1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
                            <span class="c1"># print(ratio)</span>
                            <span class="n">betweensample</span> <span class="o">=</span> <span class="n">v1</span> <span class="o">+</span> <span class="p">(</span><span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>

                            <span class="c1"># ch.points.append(betweensample.to_tuple())</span>

                            <span class="k">if</span> <span class="n">growing</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">li</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                                                                        <span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># print(v1,v2,betweensample,lastlayer,currentlayer)</span>
                                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
                                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">betweensample</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>

                            <span class="n">li</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="c1"># this chunk is terminated, and allready in layerchunks /</span>

                    <span class="c1"># ch.points.append(betweensample.to_tuple())#</span>
                    <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newsample</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">newsample</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">newsample</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># terminate chunk</span>
                    <span class="n">terminatechunk</span> <span class="o">=</span> <span class="kc">True</span>

                <span class="k">if</span> <span class="n">terminatechunk</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">as_chunk</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span>
                        <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                        <span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">camPathChunkBuilder</span><span class="p">([])</span>
            <span class="n">lastsample</span> <span class="o">=</span> <span class="n">newsample</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">as_chunk</span> <span class="o">=</span> <span class="n">ch</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">()</span>
                <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                <span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">as_chunk</span><span class="p">)</span>
                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">camPathChunkBuilder</span><span class="p">([])</span>

            <span class="c1"># PARENTING</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PARALLEL&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;CROSS&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;OUTLINEFILL&#39;</span><span class="p">:</span>
                <span class="n">timingstart</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>
                <span class="n">parentChildDist</span><span class="p">(</span><span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lastrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">o</span><span class="p">)</span>
                <span class="n">timingadd</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>

        <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="n">thisrunchunks</span>

    <span class="c1"># print(len(layerchunks[i]))</span>
    <span class="n">progress</span><span class="p">(</span><span class="s1">&#39;Checking Relations Between Paths&#39;</span><span class="p">)</span>
    <span class="n">timingstart</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PARALLEL&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;CROSS&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;OUTLINEFILL&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># sorting help so that upper layers go first always</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">layers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">children</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># only pick chunks that should have connectivity assigned - &#39;last&#39; and &#39;first&#39; ones of the layer.</span>
                <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                        <span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ch1</span> <span class="ow">in</span> <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">ch1</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch1</span><span class="p">)</span>

                <span class="c1"># parent only last and first chunk, before it did this for all.</span>
                <span class="n">parentChild</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">children</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
    <span class="n">timingadd</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">ramp</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">zstart</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">zend</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="n">timingadd</span><span class="p">(</span><span class="n">totaltime</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">samplingtime</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">sortingtime</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">totaltime</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="sampleChunksNAxis">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.sampleChunksNAxis">[docs]</a>
<span class="k">async</span> <span class="k">def</span> <span class="nf">sampleChunksNAxis</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pathSamples</span><span class="p">,</span> <span class="n">layers</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sample chunks along a specified axis based on provided paths and layers.</span>

<span class="sd">    This function processes a set of path samples and organizes them into</span>
<span class="sd">    chunks according to specified layers. It prepares the collision world if</span>
<span class="sd">    necessary, updates the cutter&#39;s rotation based on the path samples, and</span>
<span class="sd">    handles the sampling of points along the paths. The function also</span>
<span class="sd">    manages the relationships between the sampled points and their</span>
<span class="sd">    respective layers, ensuring that the correct points are added to each</span>
<span class="sd">    chunk. The resulting chunks can be used for further processing in a 3D</span>
<span class="sd">    environment.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing properties such as min/max coordinates,</span>
<span class="sd">            cutter shape, and other relevant parameters.</span>
<span class="sd">        pathSamples (list): A list of path samples, each containing start points,</span>
<span class="sd">            end points, and rotations.</span>
<span class="sd">        layers (list): A list of layer definitions that specify the boundaries</span>
<span class="sd">            for sampling.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of sampled chunks organized by layers.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#</span>
    <span class="n">minx</span><span class="p">,</span> <span class="n">miny</span><span class="p">,</span> <span class="n">minz</span><span class="p">,</span> <span class="n">maxx</span><span class="p">,</span> <span class="n">maxy</span><span class="p">,</span> <span class="n">maxz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span>

    <span class="c1"># prepare collision world</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span><span class="p">:</span>
        <span class="n">prepareBulletCollision</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="c1"># print(&#39;getting ambient&#39;)</span>
        <span class="n">getAmbient</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">update_bullet_collision_tag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># print (o.ambient)</span>
    <span class="n">cutter</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_shape</span>
    <span class="n">cutterdepth</span> <span class="o">=</span> <span class="n">cutter</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">z</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sampling Paths&#39;</span><span class="p">)</span>

    <span class="n">totlen</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># total length of all chunks, to estimate sampling time.</span>
    <span class="k">for</span> <span class="n">chs</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="n">totlen</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chs</span><span class="o">.</span><span class="n">startpoints</span><span class="p">)</span>
    <span class="n">layerchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">minz</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">minz</span>
    <span class="n">layeractivechunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
        <span class="n">layerchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">layeractivechunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">camPathChunkBuilder</span><span class="p">([]))</span>
        <span class="n">lastrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">last_percent</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">lastz</span> <span class="o">=</span> <span class="n">minz</span>
    <span class="k">for</span> <span class="n">patternchunk</span> <span class="ow">in</span> <span class="n">pathSamples</span><span class="p">:</span>
        <span class="c1"># print (patternchunk.endpoints)</span>
        <span class="n">thisrunchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">layers</span><span class="p">:</span>
            <span class="n">thisrunchunks</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
        <span class="n">lastlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">currentlayer</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">lastsample</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># threads_count=4</span>
        <span class="n">lastrotation</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># for t in range(0,threads):</span>
        <span class="c1"># print(len(patternchunk.startpoints),len( patternchunk.endpoints))</span>
        <span class="n">spl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">patternchunk</span><span class="o">.</span><span class="n">startpoints</span><span class="p">)</span>
        <span class="c1"># ,startp in enumerate(patternchunk.startpoints):</span>
        <span class="k">for</span> <span class="n">si</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">spl</span><span class="p">):</span>
            <span class="c1"># #TODO: seems we are writing into the source chunk ,</span>
            <span class="c1">#  and that is why we need to write endpoints everywhere too?</span>

            <span class="n">percent</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="n">n</span> <span class="o">/</span> <span class="n">totlen</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">percent</span> <span class="o">!=</span> <span class="n">last_percent</span><span class="p">:</span>
                <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s1">&#39;sampling paths&#39;</span><span class="p">,</span> <span class="n">percent</span><span class="p">)</span>
                <span class="n">last_percent</span> <span class="o">=</span> <span class="n">percent</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">sampled</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># print(si)</span>

            <span class="c1"># get the vector to sample</span>
            <span class="n">startp</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">patternchunk</span><span class="o">.</span><span class="n">startpoints</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="n">endp</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">patternchunk</span><span class="o">.</span><span class="n">endpoints</span><span class="p">[</span><span class="n">si</span><span class="p">])</span>
            <span class="n">rotation</span> <span class="o">=</span> <span class="n">patternchunk</span><span class="o">.</span><span class="n">rotations</span><span class="p">[</span><span class="n">si</span><span class="p">]</span>
            <span class="n">sweepvect</span> <span class="o">=</span> <span class="n">endp</span> <span class="o">-</span> <span class="n">startp</span>
            <span class="n">sweepvect</span><span class="o">.</span><span class="n">normalize</span><span class="p">()</span>
            <span class="c1"># sampling</span>
            <span class="k">if</span> <span class="n">rotation</span> <span class="o">!=</span> <span class="n">lastrotation</span><span class="p">:</span>

                <span class="n">cutter</span><span class="o">.</span><span class="n">rotation_euler</span> <span class="o">=</span> <span class="n">rotation</span>
                <span class="c1"># cutter.rotation_euler.x=-cutter.rotation_euler.x</span>
                <span class="c1"># print(rotation)</span>

                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_type</span> <span class="o">==</span> <span class="s1">&#39;VCARVE&#39;</span><span class="p">:</span>  <span class="c1"># Bullet cone is always pointing Up Z in the object</span>
                    <span class="n">cutter</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">pi</span>
                <span class="n">cutter</span><span class="o">.</span><span class="n">update_tag</span><span class="p">()</span>
                <span class="c1"># this has to be :( it resets the rigidbody world.</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">frame_set</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># No other way to update it probably now :(</span>
                <span class="c1"># actually 2 frame jumps are needed.</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">frame_set</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">frame_set</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">newsample</span> <span class="o">=</span> <span class="n">getSampleBulletNAxis</span><span class="p">(</span><span class="n">cutter</span><span class="p">,</span> <span class="n">startp</span><span class="p">,</span> <span class="n">endp</span><span class="p">,</span> <span class="n">rotation</span><span class="p">,</span> <span class="n">cutterdepth</span><span class="p">)</span>

            <span class="c1"># print(&#39;totok&#39;,startp,endp,rotation,newsample)</span>
            <span class="c1">################################</span>
            <span class="c1"># handling samples</span>
            <span class="c1">############################################</span>
            <span class="c1"># this is weird, but will leave it this way now.. just prototyping here.</span>
            <span class="k">if</span> <span class="n">newsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">sampled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># TODO: why was this here?</span>
                <span class="n">newsample</span> <span class="o">=</span> <span class="n">startp</span>
                <span class="n">sampled</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># print(newsample)</span>

            <span class="c1"># elif o.ambient_behaviour==&#39;ALL&#39; and not o.inverse:#handle ambient here</span>
            <span class="c1"># newsample=(x,y,minz)</span>
            <span class="k">if</span> <span class="n">sampled</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
                    <span class="n">terminatechunk</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                    <span class="c1"># print(i,l)</span>
                    <span class="c1"># print(l[1],l[0])</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="n">startp</span> <span class="o">-</span> <span class="n">newsample</span>
                    <span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="n">v</span><span class="o">.</span><span class="n">length</span>

                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">distance</span> <span class="o">&lt;=</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                        <span class="n">lastlayer</span> <span class="o">=</span> <span class="n">currentlayer</span>
                        <span class="n">currentlayer</span> <span class="o">=</span> <span class="n">i</span>

                        <span class="k">if</span> <span class="n">lastsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lastlayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">currentlayer</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> \
                                <span class="ow">and</span> <span class="n">lastlayer</span> <span class="o">!=</span> <span class="n">currentlayer</span><span class="p">:</span>  <span class="c1"># sampling for sorted paths in layers-</span>
                            <span class="c1"># to go to the border of the sampled layer at least...</span>
                            <span class="c1"># there was a bug here, but should be fixed.</span>
                            <span class="k">if</span> <span class="n">currentlayer</span> <span class="o">&lt;</span> <span class="n">lastlayer</span><span class="p">:</span>
                                <span class="n">growing</span> <span class="o">=</span> <span class="kc">True</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">currentlayer</span><span class="p">,</span> <span class="n">lastlayer</span><span class="p">)</span>
                                <span class="n">spliti</span> <span class="o">=</span> <span class="mi">1</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">r</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">lastlayer</span><span class="p">,</span> <span class="n">currentlayer</span><span class="p">)</span>
                                <span class="n">growing</span> <span class="o">=</span> <span class="kc">False</span>
                                <span class="n">spliti</span> <span class="o">=</span> <span class="mi">0</span>
                            <span class="c1"># print(r)</span>
                            <span class="n">li</span> <span class="o">=</span> <span class="mi">0</span>

                            <span class="k">for</span> <span class="n">ls</span> <span class="ow">in</span> <span class="n">r</span><span class="p">:</span>
                                <span class="n">splitdistance</span> <span class="o">=</span> <span class="n">layers</span><span class="p">[</span><span class="n">ls</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

                                <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="n">splitdistance</span> <span class="o">-</span> <span class="n">lastdistance</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">distance</span> <span class="o">-</span> <span class="n">lastdistance</span><span class="p">)</span>
                                <span class="c1"># print(ratio)</span>
                                <span class="n">betweensample</span> <span class="o">=</span> <span class="n">lastsample</span> <span class="o">+</span> <span class="p">(</span><span class="n">newsample</span> <span class="o">-</span> <span class="n">lastsample</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="c1"># this probably doesn&#39;t work at all!!!! check this algoritm&gt;</span>
                                <span class="n">betweenrotation</span> <span class="o">=</span> <span class="n">tuple_add</span><span class="p">(</span><span class="n">lastrotation</span><span class="p">,</span>
                                                            <span class="n">tuple_mul</span><span class="p">(</span><span class="n">tuple_sub</span><span class="p">(</span><span class="n">rotation</span><span class="p">,</span> <span class="n">lastrotation</span><span class="p">),</span> <span class="n">ratio</span><span class="p">))</span>
                                <span class="c1"># startpoint = retract point, it has to be always available...</span>
                                <span class="n">betweenstartpoint</span> <span class="o">=</span> <span class="n">laststartpoint</span> <span class="o">+</span> \
                                    <span class="p">(</span><span class="n">startp</span> <span class="o">-</span> <span class="n">laststartpoint</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="c1"># here, we need to have also possible endpoints always..</span>
                                <span class="n">betweenendpoint</span> <span class="o">=</span> <span class="n">lastendpoint</span> <span class="o">+</span> <span class="p">(</span><span class="n">endp</span> <span class="o">-</span> <span class="n">lastendpoint</span><span class="p">)</span> <span class="o">*</span> <span class="n">ratio</span>
                                <span class="k">if</span> <span class="n">growing</span><span class="p">:</span>
                                    <span class="k">if</span> <span class="n">li</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenrotation</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                                            <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenstartpoint</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenendpoint</span><span class="p">)</span>
                                    <span class="k">else</span><span class="p">:</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenrotation</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenstartpoint</span><span class="p">)</span>
                                        <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenendpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenrotation</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenstartpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenendpoint</span><span class="p">)</span>
                                <span class="k">else</span><span class="p">:</span>

                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweensample</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenrotation</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenstartpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">betweenendpoint</span><span class="p">)</span>

                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweensample</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenrotation</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenstartpoint</span><span class="p">)</span>
                                    <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">ls</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">betweenendpoint</span><span class="p">)</span>

                                <span class="c1"># layeractivechunks[ls+1].points.insert(0,betweensample)</span>
                                <span class="n">li</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="c1"># this chunk is terminated, and allready in layerchunks /</span>

                        <span class="c1"># ch.points.append(betweensample)#</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">newsample</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span>
                        <span class="n">lastdistance</span> <span class="o">=</span> <span class="n">distance</span>

                    <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">distance</span><span class="p">:</span>
                        <span class="n">v</span> <span class="o">=</span> <span class="n">sweepvect</span> <span class="o">*</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">startp</span> <span class="o">-</span> <span class="n">v</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">distance</span><span class="p">:</span>  <span class="c1"># retract to original track</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rotation</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">startp</span><span class="p">)</span>
                        <span class="n">ch</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">endp</span><span class="p">)</span>

            <span class="n">lastsample</span> <span class="o">=</span> <span class="n">newsample</span>
            <span class="n">lastrotation</span> <span class="o">=</span> <span class="n">rotation</span>
            <span class="n">laststartpoint</span> <span class="o">=</span> <span class="n">startp</span>
            <span class="n">lastendpoint</span> <span class="o">=</span> <span class="n">endp</span>

        <span class="c1"># convert everything to actual chunks</span>
        <span class="c1"># rather than chunkBuilders</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">to_chunk</span><span class="p">(</span>
            <span class="p">)</span> <span class="k">if</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
                <span class="n">layeractivechunks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">camPathChunkBuilder</span><span class="p">([])</span>

            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PARALLEL&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;CROSS&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;OUTLINEFILL&#39;</span><span class="p">:</span>
                <span class="n">parentChildDist</span><span class="p">(</span><span class="n">thisrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">lastrunchunks</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">o</span><span class="p">)</span>

        <span class="n">lastrunchunks</span> <span class="o">=</span> <span class="n">thisrunchunks</span>

    <span class="c1"># print(len(layerchunks[i]))</span>

    <span class="n">progress</span><span class="p">(</span><span class="s1">&#39;Checking Relations Between Paths&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;#this algorithm should also work for n-axis, but now is &quot;sleeping&quot;</span>
<span class="sd">    if (o.strategy==&#39;PARALLEL&#39; or o.strategy==&#39;CROSS&#39;):</span>
<span class="sd">        if len(layers)&gt;1:# sorting help so that upper layers go first always</span>
<span class="sd">            for i in range(0,len(layers)-1):</span>
<span class="sd">                #print(&#39;layerstuff parenting&#39;)</span>
<span class="sd">                parentChild(layerchunks[i+1],layerchunks[i],o)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">layers</span><span class="p">):</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">layerchunks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">chunks</span></div>



<div class="viewcode-block" id="extendChunks5axis">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.extendChunks5axis">[docs]</a>
<span class="k">def</span> <span class="nf">extendChunks5axis</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extend chunks with 5-axis cutter start and end points.</span>

<span class="sd">    This function modifies the provided chunks by appending calculated start</span>
<span class="sd">    and end points for a cutter based on the specified orientation and</span>
<span class="sd">    movement parameters. It determines the starting position of the cutter</span>
<span class="sd">    based on the machine&#39;s settings and the object&#39;s movement constraints.</span>
<span class="sd">    The function iterates through each point in the chunks and updates their</span>
<span class="sd">    start and end points accordingly.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunks (list): A list of chunk objects that will be modified.</span>
<span class="sd">        o (object): An object containing movement and orientation data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_machine</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">free_height</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">free_height</span>  <span class="c1"># o.max.z +</span>
    <span class="k">if</span> <span class="n">m</span><span class="o">.</span><span class="n">use_position_definitions</span><span class="p">:</span>  <span class="c1"># dhull</span>
        <span class="n">cutterstart</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">m</span><span class="o">.</span><span class="n">starting_position</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">starting_position</span><span class="o">.</span><span class="n">y</span><span class="p">,</span>
                              <span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">starting_position</span><span class="o">.</span><span class="n">z</span><span class="p">)))</span>  <span class="c1"># start point for casting</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># start point for casting</span>
        <span class="n">cutterstart</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span><span class="p">,</span> <span class="n">free_height</span><span class="p">)))</span>
    <span class="n">cutterend</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
    <span class="n">oriname</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; orientation&#39;</span>
    <span class="n">ori</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oriname</span><span class="p">]</span>
    <span class="c1"># rotationaxes = rotTo2axes(ori.rotation_euler,&#39;CA&#39;)#warning-here it allready is reset to 0!!</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;rot&#39;</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">rotationaxes</span><span class="p">)</span>
    <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotationaxes</span>  <span class="c1"># this is all nonsense by now.</span>
    <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">chunk</span><span class="o">.</span><span class="n">points</span><span class="p">:</span>
            <span class="n">cutterstart</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cutterstart</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">cutterend</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cutterend</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutterstart</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cutterend</span><span class="o">.</span><span class="n">to_tuple</span><span class="p">())</span>
            <span class="n">chunk</span><span class="o">.</span><span class="n">rotations</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># TODO: this is a placeholder. It does 99.9% probably write total nonsense.</span></div>



<div class="viewcode-block" id="curveToShapely">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.curveToShapely">[docs]</a>
<span class="k">def</span> <span class="nf">curveToShapely</span><span class="p">(</span><span class="n">cob</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a curve object to Shapely polygons.</span>

<span class="sd">    This function takes a curve object and converts it into a list of</span>
<span class="sd">    Shapely polygons. It first breaks the curve into chunks and then</span>
<span class="sd">    transforms those chunks into Shapely-compatible polygon representations.</span>
<span class="sd">    The `use_modifiers` parameter allows for additional processing of the</span>
<span class="sd">    curve before conversion, depending on the specific requirements of the</span>
<span class="sd">    application.</span>

<span class="sd">    Args:</span>
<span class="sd">        cob: The curve object to be converted.</span>
<span class="sd">        use_modifiers (bool): A flag indicating whether to apply modifiers</span>
<span class="sd">            during the conversion process. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of Shapely polygons created from the curve object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="n">curveToChunks</span><span class="p">(</span><span class="n">cob</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="p">)</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="n">chunksToShapely</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">polys</span></div>



<span class="c1"># separate function in blender, so you can offset any curve.</span>
<span class="c1"># FIXME: same algorithms as the cutout strategy, because that is hierarchy-respecting.</span>

<div class="viewcode-block" id="silhoueteOffset">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.silhoueteOffset">[docs]</a>
<span class="k">def</span> <span class="nf">silhoueteOffset</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">style</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mitrelimit</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Offset the silhouette of a curve or font object in Blender.</span>

<span class="sd">    This function takes an active curve or font object in Blender and</span>
<span class="sd">    creates an offset silhouette based on the specified parameters. It first</span>
<span class="sd">    retrieves the silhouette of the object and then applies a buffer</span>
<span class="sd">    operation to create the offset shape. The resulting shape is then</span>
<span class="sd">    converted back into a curve object in the Blender scene.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (bpy.context): The current Blender context.</span>
<span class="sd">        offset (float): The distance to offset the silhouette.</span>
<span class="sd">        style (int?): The join style for the offset. Defaults to 1.</span>
<span class="sd">        mitrelimit (float?): The mitre limit for the offset. Defaults to 1.0.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary indicating the operation is finished.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
    <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;CURVE&#39;</span> <span class="ow">or</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;FONT&#39;</span><span class="p">:</span>
        <span class="n">silhs</span> <span class="o">=</span> <span class="n">curveToShapely</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">silhs</span> <span class="o">=</span> <span class="n">getObjectSilhouete</span><span class="p">(</span><span class="s1">&#39;OBJECTS&#39;</span><span class="p">,</span> <span class="p">[</span><span class="n">ob</span><span class="p">])</span>

    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">silhs</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;offset attributes:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">style</span><span class="p">)</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">cap_style</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">join_style</span><span class="o">=</span><span class="n">style</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">mitre_limit</span><span class="o">=</span><span class="n">mitrelimit</span><span class="p">)</span>
    <span class="n">shapelyToCurve</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_offset_&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="mi">5</span><span class="p">)),</span> <span class="n">mp</span><span class="p">,</span> <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">curve_remove_doubles</span><span class="p">()</span>
    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;FINISHED&#39;</span><span class="p">}</span></div>



<div class="viewcode-block" id="polygonBoolean">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.polygonBoolean">[docs]</a>
<span class="k">def</span> <span class="nf">polygonBoolean</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="n">boolean_type</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Perform a boolean operation on selected polygons.</span>

<span class="sd">    This function takes the active object and applies a specified boolean</span>
<span class="sd">    operation (UNION, DIFFERENCE, or INTERSECT) with respect to other</span>
<span class="sd">    selected objects in the Blender context. It first converts the polygons</span>
<span class="sd">    of the active object and the selected objects into a Shapely</span>
<span class="sd">    MultiPolygon. Depending on the boolean type specified, it performs the</span>
<span class="sd">    corresponding boolean operation and then converts the result back into a</span>
<span class="sd">    Blender curve.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (bpy.context): The Blender context containing scene and object data.</span>
<span class="sd">        boolean_type (str): The type of boolean operation to perform.</span>
<span class="sd">            Must be one of &#39;UNION&#39;, &#39;DIFFERENCE&#39;, or &#39;INTERSECT&#39;.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary indicating the operation result, typically {&#39;FINISHED&#39;}.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
    <span class="n">obs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ob1</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">selected_objects</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ob1</span> <span class="o">!=</span> <span class="n">ob</span><span class="p">:</span>
            <span class="n">obs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ob1</span><span class="p">)</span>
    <span class="n">plist</span> <span class="o">=</span> <span class="n">curveToShapely</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
    <span class="n">p1</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">(</span><span class="n">plist</span><span class="p">)</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">obs</span><span class="p">:</span>
        <span class="n">plist</span> <span class="o">=</span> <span class="n">curveToShapely</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">MultiPolygon</span><span class="p">(</span><span class="n">plist</span><span class="p">)</span>
        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="c1"># print(polys)</span>
    <span class="k">if</span> <span class="n">boolean_type</span> <span class="o">==</span> <span class="s1">&#39;UNION&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">boolean_type</span> <span class="o">==</span> <span class="s1">&#39;DIFFERENCE&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">boolean_type</span> <span class="o">==</span> <span class="s1">&#39;INTERSECT&#39;</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">p2</span> <span class="ow">in</span> <span class="n">polys</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">p2</span><span class="p">)</span>

    <span class="n">shapelyToCurve</span><span class="p">(</span><span class="s1">&#39;boolean&#39;</span><span class="p">,</span> <span class="n">p1</span><span class="p">,</span> <span class="n">ob</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="c1"># bpy.ops.object.convert(target=&#39;CURVE&#39;)</span>
    <span class="c1"># bpy.context.scene.cursor_location=ob.location</span>
    <span class="c1"># bpy.ops.object.origin_set(type=&#39;ORIGIN_CURSOR&#39;)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;FINISHED&#39;</span><span class="p">}</span></div>



<div class="viewcode-block" id="polygonConvexHull">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.polygonConvexHull">[docs]</a>
<span class="k">def</span> <span class="nf">polygonConvexHull</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate the convex hull of a polygon from the given context.</span>

<span class="sd">    This function duplicates the current object, joins it, and converts it</span>
<span class="sd">    into a 3D mesh. It then extracts the X and Y coordinates of the vertices</span>
<span class="sd">    to create a MultiPoint data structure using Shapely. Finally, it</span>
<span class="sd">    computes the convex hull of these points and converts the result back</span>
<span class="sd">    into a curve named &#39;ConvexHull&#39;. Temporary objects created during this</span>
<span class="sd">    process are deleted to maintain a clean workspace.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the operation is performed, typically</span>
<span class="sd">            related to Blender&#39;s current state.</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: A dictionary indicating the operation&#39;s completion status.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">duplicate</span><span class="p">()</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="s1">&#39;3D&#39;</span>  <span class="c1"># force curve to be a 3D curve</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">transform_apply</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;_tmp&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="s1">&#39;MESH&#39;</span><span class="p">)</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>  <span class="c1"># extract X,Y coordinates from the vertices data</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">co</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

    <span class="n">select_multiple</span><span class="p">(</span><span class="s1">&#39;_tmp&#39;</span><span class="p">)</span>  <span class="c1"># delete temporary mesh</span>
    <span class="n">select_multiple</span><span class="p">(</span><span class="s1">&#39;ConvexHull&#39;</span><span class="p">)</span>  <span class="c1"># delete old hull</span>

    <span class="c1"># convert coordinates to shapely MultiPoint datastructure</span>
    <span class="n">points</span> <span class="o">=</span> <span class="n">sgeometry</span><span class="o">.</span><span class="n">MultiPoint</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="n">hull</span> <span class="o">=</span> <span class="n">points</span><span class="o">.</span><span class="n">convex_hull</span>
    <span class="n">shapelyToCurve</span><span class="p">(</span><span class="s1">&#39;ConvexHull&#39;</span><span class="p">,</span> <span class="n">hull</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

    <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;FINISHED&#39;</span><span class="p">}</span></div>



<div class="viewcode-block" id="Helix">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.Helix">[docs]</a>
<span class="k">def</span> <span class="nf">Helix</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">np</span><span class="p">,</span> <span class="n">zstart</span><span class="p">,</span> <span class="n">pend</span><span class="p">,</span> <span class="n">rev</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generate a helix of points in 3D space.</span>

<span class="sd">    This function calculates a series of points that form a helix based on</span>
<span class="sd">    the specified parameters. It starts from a given radius and</span>
<span class="sd">    z-coordinate, and generates points by rotating around the z-axis while</span>
<span class="sd">    moving linearly along the z-axis. The number of points generated is</span>
<span class="sd">    determined by the number of turns (revolutions) and the number of points</span>
<span class="sd">    per revolution.</span>

<span class="sd">    Args:</span>
<span class="sd">        r (float): The radius of the helix.</span>
<span class="sd">        np (int): The number of points per revolution.</span>
<span class="sd">        zstart (float): The starting z-coordinate for the helix.</span>
<span class="sd">        pend (tuple): A tuple containing the x, y, and z coordinates of the endpoint.</span>
<span class="sd">        rev (int): The number of revolutions to complete.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of tuples representing the coordinates of the points in the</span>
<span class="sd">            helix.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">c</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">zstart</span><span class="p">))</span>
    <span class="n">e</span> <span class="o">=</span> <span class="n">Euler</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">np</span><span class="p">))</span>
    <span class="n">zstep</span> <span class="o">=</span> <span class="p">(</span><span class="n">zstart</span> <span class="o">-</span> <span class="n">pend</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">/</span> <span class="p">(</span><span class="n">np</span> <span class="o">*</span> <span class="n">rev</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span> <span class="o">*</span> <span class="n">rev</span><span class="p">)):</span>
        <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">pend</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">pend</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">zstart</span> <span class="o">-</span> <span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">zstep</span><span class="p">)))</span>
        <span class="n">v</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="n">c</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">pend</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">pend</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pend</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">c</span></div>



<div class="viewcode-block" id="comparezlevel">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.comparezlevel">[docs]</a>
<span class="k">def</span> <span class="nf">comparezlevel</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span></div>



<div class="viewcode-block" id="overlaps">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.overlaps">[docs]</a>
<span class="k">def</span> <span class="nf">overlaps</span><span class="p">(</span><span class="n">bb1</span><span class="p">,</span> <span class="n">bb2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Determine if one bounding box is a child of another.</span>

<span class="sd">    This function checks if the first bounding box (bb1) is completely</span>
<span class="sd">    contained within the second bounding box (bb2). It does this by</span>
<span class="sd">    comparing the coordinates of both bounding boxes to see if all corners</span>
<span class="sd">    of bb1 are within the bounds of bb2.</span>

<span class="sd">    Args:</span>
<span class="sd">        bb1 (tuple): A tuple representing the coordinates of the first bounding box</span>
<span class="sd">            in the format (x_min, y_min, x_max, y_max).</span>
<span class="sd">        bb2 (tuple): A tuple representing the coordinates of the second bounding box</span>
<span class="sd">            in the format (x_min, y_min, x_max, y_max).</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if bb1 is a child of bb2, otherwise False.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  <span class="c1"># true if bb1 is child of bb2</span>
    <span class="n">ch1</span> <span class="o">=</span> <span class="n">bb1</span>
    <span class="n">ch2</span> <span class="o">=</span> <span class="n">bb2</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ch2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ch1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ch1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ch2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">ch2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ch1</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ch1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">ch2</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
        <span class="k">return</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="connectChunksLow">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.connectChunksLow">[docs]</a>
<span class="k">async</span> <span class="k">def</span> <span class="nf">connectChunksLow</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Connects chunks that are close to each other without lifting, sampling</span>
<span class="sd">    them &#39;low&#39;.</span>

<span class="sd">    This function processes a list of chunks and connects those that are</span>
<span class="sd">    within a specified distance based on the provided options. It takes into</span>
<span class="sd">    account various strategies for connecting the chunks, including &#39;CARVE&#39;,</span>
<span class="sd">    &#39;PENCIL&#39;, and &#39;MEDIAL_AXIS&#39;, and adjusts the merging distance</span>
<span class="sd">    accordingly. The function also handles specific movement settings, such</span>
<span class="sd">    as whether to stay low or to merge distances, and may resample chunks if</span>
<span class="sd">    certain optimization conditions are met.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunks (list): A list of chunk objects to be connected.</span>
<span class="sd">        o (object): An options object containing movement and strategy parameters.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of connected chunk objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">stay_low</span> <span class="ow">or</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;CARVE&#39;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">carve_depth</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">chunks</span>

    <span class="n">connectedchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunks_to_resample</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># for OpenCAMLib sampling</span>
    <span class="n">mergedist</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">dist_between_paths</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PENCIL&#39;</span><span class="p">:</span>  <span class="c1"># this is bigger for pencil path since it goes on the surface to clean up the rests,</span>
        <span class="c1"># and can go to close points on the surface without fear of going deep into material.</span>
        <span class="n">mergedist</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">dist_between_paths</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;MEDIAL_AXIS&#39;</span><span class="p">:</span>
        <span class="n">mergedist</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">medial_axis_subdivision</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">parallel_step_back</span><span class="p">:</span>
        <span class="n">mergedist</span> <span class="o">*=</span> <span class="mi">2</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">merge_dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">mergedist</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">movement</span><span class="o">.</span><span class="n">merge_dist</span>
    <span class="c1"># mergedist=10</span>
    <span class="n">lastch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ch</span><span class="o">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">lastch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">distStart</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mergedist</span><span class="p">):</span>
                <span class="c1"># CARVE should lift allways, when it goes below surface...</span>
                <span class="c1"># print(mergedist,ch.dist(pos,o))</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PARALLEL&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;CROSS&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PENCIL&#39;</span><span class="p">:</span>
                    <span class="c1"># for these paths sorting happens after sampling, thats why they need resample the connection</span>
                    <span class="n">between</span> <span class="o">=</span> <span class="n">samplePathLow</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">lastch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># print(&#39;addbetwee&#39;)</span>
                    <span class="n">between</span> <span class="o">=</span> <span class="n">samplePathLow</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">lastch</span><span class="p">,</span> <span class="n">ch</span><span class="p">,</span>
                                            <span class="kc">False</span><span class="p">)</span>  <span class="c1"># other paths either dont use sampling or are sorted before it.</span>
                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="ow">and</span> <span class="p">(</span>
                        <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PARALLEL&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;CROSS&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;PENCIL&#39;</span><span class="p">):</span>
                    <span class="n">chunks_to_resample</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span> <span class="n">between</span><span class="o">.</span><span class="n">count</span><span class="p">()))</span>

                <span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">between</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">())</span>
                <span class="n">connectedchunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ch</span><span class="o">.</span><span class="n">get_points_np</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">connectedchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">lastch</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">lastch</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;CUTOUT&#39;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;POCKET&#39;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;WATERLINE&#39;</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">oclResampleChunks</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">chunks_to_resample</span><span class="p">,</span> <span class="n">use_cached_mesh</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">connectedchunks</span></div>



<div class="viewcode-block" id="getClosest">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getClosest">[docs]</a>
<span class="k">def</span> <span class="nf">getClosest</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">chunks</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Find the closest chunk to a given position.</span>

<span class="sd">    This function iterates through a list of chunks and determines which</span>
<span class="sd">    chunk is closest to the specified position. It checks if each chunk&#39;s</span>
<span class="sd">    children are sorted before calculating the distance. The chunk with the</span>
<span class="sd">    minimum distance to the given position is returned.</span>

<span class="sd">    Args:</span>
<span class="sd">        o: An object representing the origin point.</span>
<span class="sd">        pos: A position to which the closest chunk is calculated.</span>
<span class="sd">        chunks (list): A list of chunk objects to evaluate.</span>

<span class="sd">    Returns:</span>
<span class="sd">        Chunk: The closest chunk object to the specified position, or None if no valid</span>
<span class="sd">            chunk is found.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># ch=-1</span>
    <span class="n">mind</span> <span class="o">=</span> <span class="mi">2000</span>
    <span class="n">d</span> <span class="o">=</span> <span class="mi">100000000000</span>
    <span class="n">ch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">for</span> <span class="n">chtest</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="n">cango</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># here was chtest.getNext==chtest, was doing recursion error and slowing down.</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">chtest</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">child</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                <span class="n">cango</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="n">cango</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">chtest</span><span class="o">.</span><span class="n">dist</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">mind</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">chtest</span>
                <span class="n">mind</span> <span class="o">=</span> <span class="n">d</span>
    <span class="k">return</span> <span class="n">ch</span></div>



<div class="viewcode-block" id="sortChunks">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.sortChunks">[docs]</a>
<span class="k">async</span> <span class="k">def</span> <span class="nf">sortChunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">last_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sort a list of chunks based on a specified strategy.</span>

<span class="sd">    This function sorts a list of chunks according to the provided options</span>
<span class="sd">    and the current position. It utilizes a recursive approach to find the</span>
<span class="sd">    closest chunk to the current position and adapts its distance if it has</span>
<span class="sd">    not been sorted before. The function also handles progress updates</span>
<span class="sd">    asynchronously and adjusts the recursion limit to accommodate deep</span>
<span class="sd">    recursion scenarios.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunks (list): A list of chunk objects to be sorted.</span>
<span class="sd">        o (object): An options object that contains sorting strategy and other parameters.</span>
<span class="sd">        last_pos (tuple?): The last known position as a tuple of coordinates.</span>
<span class="sd">            Defaults to None, which initializes the position to (0, 0, 0).</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A sorted list of chunk objects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;WATERLINE&#39;</span><span class="p">:</span>
        <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s1">&#39;sorting paths&#39;</span><span class="p">)</span>
    <span class="c1"># the getNext() function of CamPathChunk was running out of recursion limits.</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">100000</span><span class="p">)</span>
    <span class="n">sortedchunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">chunks_to_resample</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">lastch</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">last_progress_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">total</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">last_pos</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">last_pos</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;WATERLINE&#39;</span> <span class="ow">and</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span><span class="o">-</span><span class="n">last_progress_time</span> <span class="o">&gt;</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="k">await</span> <span class="n">progress_async</span><span class="p">(</span><span class="s2">&quot;Sorting paths&quot;</span><span class="p">,</span> <span class="mf">100.0</span><span class="o">*</span><span class="p">(</span><span class="n">total</span><span class="o">-</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span><span class="o">/</span><span class="n">total</span><span class="p">)</span>
            <span class="n">last_progress_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">ch</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sortedchunks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">lastch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># first chunk or when there are no parents -&gt; parents come after children here...</span>
            <span class="n">ch</span> <span class="o">=</span> <span class="n">getClosest</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">lastch</span><span class="o">.</span><span class="n">parents</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># looks in parents for next candidate, recursively</span>
            <span class="k">for</span> <span class="n">parent</span> <span class="ow">in</span> <span class="n">lastch</span><span class="o">.</span><span class="n">parents</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">getNextClosest</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">break</span>
            <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ch</span> <span class="o">=</span> <span class="n">getClosest</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">chunks</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ch</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>  <span class="c1"># found next chunk, append it to list</span>
            <span class="c1"># only adaptdist the chunk if it has not been sorted before</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">ch</span><span class="o">.</span><span class="n">sorted</span><span class="p">:</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">adaptdist</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
                <span class="n">ch</span><span class="o">.</span><span class="n">sorted</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># print(len(ch.parents),&#39;children&#39;)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">sortedchunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ch</span><span class="p">)</span>
            <span class="n">lastch</span> <span class="o">=</span> <span class="n">ch</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">lastch</span><span class="o">.</span><span class="n">get_point</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># print(i, len(chunks))</span>
        <span class="c1"># experimental fix for infinite loop problem</span>
        <span class="c1"># else:</span>
        <span class="c1"># THIS PROBLEM WASN&#39;T HERE AT ALL. but keeping it here, it might fix the problems somwhere else:)</span>
        <span class="c1"># can&#39;t find chunks close enough and still some chunks left</span>
        <span class="c1"># to be sorted. For now just move the remaining chunks over to</span>
        <span class="c1"># the sorted list.</span>
        <span class="c1"># This fixes an infinite loop condition that occurs sometimes.</span>
        <span class="c1"># This is a bandaid fix: need to find the root cause of this problem</span>
        <span class="c1"># suspect it has to do with the sorted flag?</span>
        <span class="c1"># print(&quot;no chunks found closest. Chunks not sorted: &quot;, len(chunks))</span>
        <span class="c1"># sortedchunks.extend(chunks)</span>
        <span class="c1"># chunks[:] = []</span>

        <span class="n">i</span> <span class="o">-=</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;POCKET&#39;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">pocket_option</span> <span class="o">==</span> <span class="s1">&#39;OUTSIDE&#39;</span><span class="p">:</span>
        <span class="n">sortedchunks</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>

    <span class="n">sys</span><span class="o">.</span><span class="n">setrecursionlimit</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;DRILL&#39;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">!=</span> <span class="s1">&#39;OUTLINEFILL&#39;</span><span class="p">:</span>
        <span class="c1"># THIS SHOULD AVOID ACTUALLY MOST STRATEGIES, THIS SHOULD BE DONE MANUALLY,</span>
        <span class="c1"># BECAUSE SOME STRATEGIES GET SORTED TWICE.</span>
        <span class="n">sortedchunks</span> <span class="o">=</span> <span class="k">await</span> <span class="n">connectChunksLow</span><span class="p">(</span><span class="n">sortedchunks</span><span class="p">,</span> <span class="n">o</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sortedchunks</span></div>



<span class="c1"># most right vector from a set regarding angle..</span>
<div class="viewcode-block" id="getVectorRight">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getVectorRight">[docs]</a>
<span class="k">def</span> <span class="nf">getVectorRight</span><span class="p">(</span><span class="n">lastv</span><span class="p">,</span> <span class="n">verts</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the index of the vector that is most to the right based on angle.</span>

<span class="sd">    This function calculates the angle between a reference vector (formed by</span>
<span class="sd">    the last two vectors in `lastv`) and each vector in the `verts` list. It</span>
<span class="sd">    identifies the vector that has the smallest angle with respect to the</span>
<span class="sd">    reference vector, indicating that it is the most rightward vector in</span>
<span class="sd">    relation to the specified direction.</span>

<span class="sd">    Args:</span>
<span class="sd">        lastv (list): A list containing two vectors, where each vector is</span>
<span class="sd">            represented as a tuple or list of coordinates.</span>
<span class="sd">        verts (list): A list of vectors represented as tuples or lists of</span>
<span class="sd">            coordinates.</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: The index of the vector in `verts` that is most to the right</span>
<span class="sd">            based on the calculated angle.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">defa</span> <span class="o">=</span> <span class="mi">100</span>
    <span class="n">v1</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">lastv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">v2</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">lastv</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">va</span> <span class="o">=</span> <span class="n">v2</span> <span class="o">-</span> <span class="n">v1</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">verts</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">v</span> <span class="o">!=</span> <span class="n">lastv</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="n">vb</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">-</span> <span class="n">v2</span>
            <span class="n">a</span> <span class="o">=</span> <span class="n">va</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">vb</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">a</span> <span class="o">&lt;</span> <span class="n">defa</span><span class="p">:</span>
                <span class="n">defa</span> <span class="o">=</span> <span class="n">a</span>
                <span class="n">returnvec</span> <span class="o">=</span> <span class="n">i</span>
    <span class="k">return</span> <span class="n">returnvec</span></div>



<div class="viewcode-block" id="cleanUpDict">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.cleanUpDict">[docs]</a>
<span class="k">def</span> <span class="nf">cleanUpDict</span><span class="p">(</span><span class="n">ndict</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove lonely points from a dictionary.</span>

<span class="sd">    This function iterates over the keys of the provided dictionary and</span>
<span class="sd">    removes any entries that contain one or fewer associated values. It</span>
<span class="sd">    continues to check for and remove &quot;lonely&quot; points until no more can be</span>
<span class="sd">    found. The process is repeated until all such entries are eliminated</span>
<span class="sd">    from the dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">        ndict (dict): A dictionary where keys are associated with lists of values.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function modifies the input dictionary in place and does not return</span>
<span class="sd">            a value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># now it should delete all junk first, iterate over lonely verts.</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Removing Lonely Points&#39;</span><span class="p">)</span>
    <span class="c1"># found_solitaires=True</span>
    <span class="c1"># while found_solitaires:</span>
    <span class="n">found_solitaires</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">keys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">keys</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">ndict</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">ndict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ndict</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">newcheck</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">while</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">newcheck</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">newcheck</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ndict</span><span class="p">[</span><span class="n">v</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">v1</span> <span class="ow">in</span> <span class="n">ndict</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                        <span class="n">newcheck</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
                    <span class="n">dictRemove</span><span class="p">(</span><span class="n">ndict</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">removed</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">found_solitaires</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">removed</span><span class="p">)</span></div>



<div class="viewcode-block" id="dictRemove">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.dictRemove">[docs]</a>
<span class="k">def</span> <span class="nf">dictRemove</span><span class="p">(</span><span class="nb">dict</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove a key and its associated values from a dictionary.</span>

<span class="sd">    This function takes a dictionary and a key (val) as input. It iterates</span>
<span class="sd">    through the list of values associated with the given key and removes the</span>
<span class="sd">    key from each of those values&#39; lists. Finally, it removes the key itself</span>
<span class="sd">    from the dictionary.</span>

<span class="sd">    Args:</span>
<span class="sd">        dict (dict): A dictionary where the key is associated with a list of values.</span>
<span class="sd">        val: The key to be removed from the dictionary and from the lists of its</span>
<span class="sd">            associated values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">dict</span><span class="p">[</span><span class="n">val</span><span class="p">]:</span>
        <span class="nb">dict</span><span class="p">[</span><span class="n">v</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
    <span class="nb">dict</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>



<div class="viewcode-block" id="addLoop">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.addLoop">[docs]</a>
<span class="k">def</span> <span class="nf">addLoop</span><span class="p">(</span><span class="n">parentloop</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a loop to a parent loop structure.</span>

<span class="sd">    This function recursively checks if the specified start and end values</span>
<span class="sd">    can be added as a new loop to the parent loop. If an existing loop</span>
<span class="sd">    encompasses the new loop, it will call itself on that loop. If no such</span>
<span class="sd">    loop exists, it appends the new loop defined by the start and end values</span>
<span class="sd">    to the parent loop&#39;s list of loops.</span>

<span class="sd">    Args:</span>
<span class="sd">        parentloop (list): A list representing the parent loop, where the</span>
<span class="sd">            third element is a list of child loops.</span>
<span class="sd">        start (int): The starting value of the new loop to be added.</span>
<span class="sd">        end (int): The ending value of the new loop to be added.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function modifies the parentloop in place and does not</span>
<span class="sd">            return a value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">added</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">parentloop</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">start</span> <span class="ow">and</span> <span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
            <span class="n">addLoop</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">return</span>
    <span class="n">parentloop</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="p">[]])</span></div>



<div class="viewcode-block" id="cutloops">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.cutloops">[docs]</a>
<span class="k">def</span> <span class="nf">cutloops</span><span class="p">(</span><span class="n">csource</span><span class="p">,</span> <span class="n">parentloop</span><span class="p">,</span> <span class="n">loops</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Cut loops from a source code segment.</span>

<span class="sd">    This function takes a source code segment and a parent loop defined by</span>
<span class="sd">    its start and end indices, along with a list of nested loops. It creates</span>
<span class="sd">    a copy of the source code segment and removes the specified nested loops</span>
<span class="sd">    from it. The modified segment is then appended to the provided list of</span>
<span class="sd">    loops. The function also recursively processes any nested loops found</span>
<span class="sd">    within the parent loop.</span>

<span class="sd">    Args:</span>
<span class="sd">        csource (str): The source code from which loops will be cut.</span>
<span class="sd">        parentloop (tuple): A tuple containing the start index, end index, and a list of nested</span>
<span class="sd">            loops.</span>
<span class="sd">            The list of nested loops should contain tuples with start and end</span>
<span class="sd">            indices for each loop.</span>
<span class="sd">        loops (list): A list that will be populated with the modified source code segments</span>
<span class="sd">            after</span>
<span class="sd">            removing the specified loops.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function modifies the `loops` list in place and does not return a</span>
<span class="sd">            value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">copy</span> <span class="o">=</span> <span class="n">csource</span><span class="p">[</span><span class="n">parentloop</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">parentloop</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">parentloop</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">parentloop</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">li</span><span class="p">]</span>
        <span class="c1"># print(l)</span>
        <span class="n">copy</span> <span class="o">=</span> <span class="n">copy</span><span class="p">[:</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">parentloop</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">copy</span><span class="p">[</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">parentloop</span><span class="p">[</span><span class="mi">0</span><span class="p">]:]</span>
    <span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">parentloop</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
        <span class="n">cutloops</span><span class="p">(</span><span class="n">csource</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">loops</span><span class="p">)</span></div>



<div class="viewcode-block" id="getOperationSilhouete">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getOperationSilhouete">[docs]</a>
<span class="k">def</span> <span class="nf">getOperationSilhouete</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Gets the silhouette for the given operation.</span>

<span class="sd">    This function determines the silhouette of an operation using image</span>
<span class="sd">    thresholding techniques. It handles different geometry sources, such as</span>
<span class="sd">    objects or images, and applies specific methods based on the type of</span>
<span class="sd">    geometry. If the geometry source is &#39;OBJECT&#39; or &#39;COLLECTION&#39;, it checks</span>
<span class="sd">    whether to process curves or not. The function also considers the number</span>
<span class="sd">    of faces in mesh objects to decide on the appropriate method for</span>
<span class="sd">    silhouette extraction.</span>

<span class="sd">    Args:</span>
<span class="sd">        operation (Operation): An object containing the necessary data</span>

<span class="sd">    Returns:</span>
<span class="sd">        Silhouette: The computed silhouette for the operation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">update_silhouete_tag</span><span class="p">:</span>
        <span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">operation</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;OBJECT&#39;</span> <span class="ow">or</span> <span class="n">operation</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;COLLECTION&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">operation</span><span class="o">.</span><span class="n">onlycurves</span><span class="p">:</span>
                <span class="n">stype</span> <span class="o">=</span> <span class="s1">&#39;OBJECTS&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stype</span> <span class="o">=</span> <span class="s1">&#39;CURVES&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stype</span> <span class="o">=</span> <span class="s1">&#39;IMAGE&#39;</span>

        <span class="n">totfaces</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;OBJECTS&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">operation</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="s1">&#39;MESH&#39;</span><span class="p">:</span>
                    <span class="n">totfaces</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;OBJECTS&#39;</span> <span class="ow">and</span> <span class="n">totfaces</span> <span class="o">&gt;</span> <span class="mi">200000</span><span class="p">)</span> <span class="ow">or</span> <span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;IMAGE&#39;</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Image Method&#39;</span><span class="p">)</span>
            <span class="n">samples</span> <span class="o">=</span> <span class="n">renderSampleImage</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;OBJECTS&#39;</span><span class="p">:</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">&gt;</span> <span class="n">operation</span><span class="o">.</span><span class="n">minz</span> <span class="o">-</span> <span class="mf">0.0000001</span>
                <span class="c1"># numpy.min(operation.zbuffer_image)-0.0000001#</span>
                <span class="c1"># #the small number solves issue with totally flat meshes, which people tend to mill instead of</span>
                <span class="c1"># proper pockets. then the minimum was also maximum, and it didn&#39;t detect contour.</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># this fixes another numeric imprecision.</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">samples</span> <span class="o">&gt;</span> <span class="n">numpy</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">zbuffer_image</span><span class="p">)</span>

            <span class="n">chunks</span> <span class="o">=</span> <span class="n">imageToChunks</span><span class="p">(</span><span class="n">operation</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="n">operation</span><span class="o">.</span><span class="n">silhouete</span> <span class="o">=</span> <span class="n">chunksToShapely</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="c1"># print(operation.silhouete)</span>
        <span class="c1"># this conversion happens because we need the silh to be oriented, for milling directions.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;object method for retrieving silhouette&#39;</span><span class="p">)</span>  <span class="c1">#</span>
            <span class="n">operation</span><span class="o">.</span><span class="n">silhouete</span> <span class="o">=</span> <span class="n">getObjectSilhouete</span><span class="p">(</span><span class="n">stype</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="n">operation</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span>
                                                     <span class="n">use_modifiers</span><span class="o">=</span><span class="n">operation</span><span class="o">.</span><span class="n">use_modifiers</span><span class="p">)</span>

        <span class="n">operation</span><span class="o">.</span><span class="n">update_silhouete_tag</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">operation</span><span class="o">.</span><span class="n">silhouete</span></div>



<div class="viewcode-block" id="getObjectSilhouete">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getObjectSilhouete">[docs]</a>
<span class="k">def</span> <span class="nf">getObjectSilhouete</span><span class="p">(</span><span class="n">stype</span><span class="p">,</span> <span class="n">objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">use_modifiers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the silhouette of objects based on the specified type.</span>

<span class="sd">    This function computes the silhouette of a given set of objects in</span>
<span class="sd">    Blender based on the specified type. It can handle both curves and mesh</span>
<span class="sd">    objects, converting curves to polygon format and calculating the</span>
<span class="sd">    silhouette for mesh objects. The function also considers the use of</span>
<span class="sd">    modifiers if specified. The silhouette is generated by processing the</span>
<span class="sd">    geometry of the objects and returning a Shapely representation of the</span>
<span class="sd">    silhouette.</span>

<span class="sd">    Args:</span>
<span class="sd">        stype (str): The type of silhouette to generate (&#39;CURVES&#39; or &#39;OBJECTS&#39;).</span>
<span class="sd">        objects (list?): A list of Blender objects to process. Defaults to None.</span>
<span class="sd">        use_modifiers (bool?): Whether to apply modifiers to the objects. Defaults to False.</span>

<span class="sd">    Returns:</span>
<span class="sd">        shapely.geometry.MultiPolygon: The computed silhouette as a Shapely MultiPolygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;stype&quot;</span><span class="p">,</span><span class="n">stype</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;CURVES&#39;</span><span class="p">:</span>  <span class="c1"># curve conversion to polygon format</span>
        <span class="n">allchunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">curveToChunks</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
            <span class="n">allchunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span>
        <span class="n">silhouete</span> <span class="o">=</span> <span class="n">chunksToShapely</span><span class="p">(</span><span class="n">allchunks</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">stype</span> <span class="o">==</span> <span class="s1">&#39;OBJECTS&#39;</span><span class="p">:</span>
        <span class="n">totfaces</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
            <span class="n">totfaces</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">polygons</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">totfaces</span> <span class="o">&lt;</span> <span class="mi">20000000</span><span class="p">:</span>  <span class="c1"># boolean polygons method originaly was 20 000 poly limit, now limitless,</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapely Getting Silhouette&#39;</span><span class="p">)</span>
            <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;object&quot;</span><span class="p">,</span><span class="n">ob</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_modifiers</span><span class="p">:</span>
                    <span class="n">ob</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">evaluated_get</span><span class="p">(</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">evaluated_depsgraph_get</span><span class="p">())</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">to_mesh</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">data</span>
                <span class="n">mw</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">matrix_world</span>
                <span class="n">mwi</span> <span class="o">=</span> <span class="n">mw</span><span class="o">.</span><span class="n">inverted</span><span class="p">()</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span>
                <span class="n">m</span><span class="o">.</span><span class="n">calc_loop_triangles</span><span class="p">()</span>
                <span class="nb">id</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">e</span> <span class="o">=</span> <span class="mf">0.000001</span>
                <span class="n">scaleup</span> <span class="o">=</span> <span class="mi">100</span>
                <span class="k">for</span> <span class="n">tri</span> <span class="ow">in</span> <span class="n">m</span><span class="o">.</span><span class="n">loop_triangles</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">tri</span><span class="o">.</span><span class="n">normal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                    <span class="n">n</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">tri</span><span class="o">.</span><span class="n">area</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n</span><span class="o">.</span><span class="n">z</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># n.z&gt;0.0 and f.area&gt;0.0 :</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">tri</span><span class="o">.</span><span class="n">center</span>
                        <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">xy</span>
                        <span class="k">for</span> <span class="n">vert_index</span> <span class="ow">in</span> <span class="n">tri</span><span class="o">.</span><span class="n">vertices</span><span class="p">:</span>
                            <span class="n">v</span> <span class="o">=</span> <span class="n">mw</span> <span class="o">@</span> <span class="n">m</span><span class="o">.</span><span class="n">vertices</span><span class="p">[</span><span class="n">vert_index</span><span class="p">]</span><span class="o">.</span><span class="n">co</span>
                            <span class="n">s</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                            <span class="c1"># print(s)</span>
                            <span class="n">p</span> <span class="o">=</span> <span class="n">spolygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                            <span class="c1"># print(dir(p))</span>
                            <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">is_valid</span><span class="p">:</span>
                                <span class="c1"># polys.append(p)</span>
                                <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
                        <span class="nb">id</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">totfaces</span> <span class="o">&lt;</span> <span class="mi">20000</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Computing in Parts&#39;</span><span class="p">)</span>
                <span class="n">bigshapes</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">part</span> <span class="o">=</span> <span class="mi">20000</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">*</span> <span class="n">part</span> <span class="o">&lt;</span> <span class="n">totfaces</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                    <span class="n">ar</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span><span class="p">:</span><span class="n">i</span> <span class="o">*</span> <span class="n">part</span><span class="p">]</span>
                    <span class="n">bigshapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">ar</span><span class="p">))</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span> <span class="o">&lt;</span> <span class="n">totfaces</span><span class="p">:</span>
                    <span class="n">last_ar</span> <span class="o">=</span> <span class="n">polys</span><span class="p">[(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">part</span><span class="p">:]</span>
                    <span class="n">bigshapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">last_ar</span><span class="p">))</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Joining&#39;</span><span class="p">)</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">sops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">bigshapes</span><span class="p">)</span>

            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;time:&quot;</span><span class="p">,</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">t</span><span class="p">)</span>

            <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
            <span class="n">silhouete</span> <span class="o">=</span> <span class="n">shapelyToMultipolygon</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>  <span class="c1"># [polygon_utils_cam.Shapely2Polygon(p)]</span>

    <span class="k">return</span> <span class="n">silhouete</span></div>



<div class="viewcode-block" id="getAmbient">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getAmbient">[docs]</a>
<span class="k">def</span> <span class="nf">getAmbient</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate and update the ambient geometry based on the provided object.</span>

<span class="sd">    This function computes the ambient shape for a given object based on its</span>
<span class="sd">    properties, such as cutter restrictions and ambient behavior. It</span>
<span class="sd">    determines the appropriate radius and creates the ambient geometry</span>
<span class="sd">    either from the silhouette or as a polygon defined by the object&#39;s</span>
<span class="sd">    minimum and maximum coordinates. If a limit curve is specified, it will</span>
<span class="sd">    also intersect the ambient shape with the limit polygon.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing properties that define the ambient behavior,</span>
<span class="sd">            cutter restrictions, and limit curve.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: The function updates the ambient property of the object in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">update_ambient_tag</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_cutter_restrict</span><span class="p">:</span>  <span class="c1"># cutter stays in ambient &amp; limit curve</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_behaviour</span> <span class="o">==</span> <span class="s1">&#39;AROUND&#39;</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_radius</span> <span class="o">-</span> <span class="n">m</span>
            <span class="c1"># in this method we need ambient from silhouete</span>
            <span class="n">o</span><span class="o">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">getObjectOutline</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">spolygon</span><span class="o">.</span><span class="n">Polygon</span><span class="p">(((</span><span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">m</span><span class="p">),</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">m</span><span class="p">),</span>
                                          <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">m</span><span class="p">),</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">m</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">m</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">use_limit_curve</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">limit_curve</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">limit_curve</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">limit_curve</span><span class="p">]</span>
                <span class="n">polys</span> <span class="o">=</span> <span class="n">curveToShapely</span><span class="p">(</span><span class="n">limit_curve</span><span class="p">)</span>
                <span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">polys</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient_cutter_restrict</span><span class="p">:</span>
                    <span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span>
                        <span class="n">o</span><span class="o">.</span><span class="n">cutter_diameter</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">circle_detail</span><span class="p">)</span>
            <span class="n">o</span><span class="o">.</span><span class="n">ambient</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">ambient</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">limit_poly</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">update_ambient_tag</span> <span class="o">=</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="getObjectOutline">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getObjectOutline">[docs]</a>
<span class="k">def</span> <span class="nf">getObjectOutline</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span> <span class="n">Offset</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the outline of a geometric object based on specified parameters.</span>

<span class="sd">    This function generates an outline for a given geometric object by</span>
<span class="sd">    applying a buffer operation to its polygons. The buffer radius can be</span>
<span class="sd">    adjusted based on the `radius` parameter, and the operation can be</span>
<span class="sd">    offset based on the `Offset` flag. The function also considers whether</span>
<span class="sd">    the polygons should be merged or not, depending on the properties of the</span>
<span class="sd">    object `o`.</span>

<span class="sd">    Args:</span>
<span class="sd">        radius (float): The radius for the buffer operation.</span>
<span class="sd">        o (object): An object containing properties that influence the outline generation.</span>
<span class="sd">        Offset (bool): A flag indicating whether to apply a positive or negative offset.</span>

<span class="sd">    Returns:</span>
<span class="sd">        MultiPolygon: The resulting outline of the geometric object as a MultiPolygon.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  <span class="c1"># FIXME: make this one operation independent</span>
    <span class="c1"># circle detail, optimize, optimize thresold.</span>

    <span class="n">polygons</span> <span class="o">=</span> <span class="n">getOperationSilhouete</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># print(&#39;offseting polygons&#39;)</span>

    <span class="k">if</span> <span class="n">Offset</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="n">outlines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">straight</span><span class="p">:</span>
        <span class="n">join</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">join</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">polygons</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">polygon_list</span> <span class="o">=</span> <span class="n">polygons</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">polygon_list</span> <span class="o">=</span> <span class="n">polygons</span><span class="o">.</span><span class="n">geoms</span>

    <span class="k">for</span> <span class="n">p1</span> <span class="ow">in</span> <span class="n">polygon_list</span><span class="p">:</span>  <span class="c1"># sort by size before this???</span>
        <span class="c1"># print(p1.type, len(polygons))</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">.</span><span class="n">buffer</span><span class="p">(</span><span class="n">radius</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span> <span class="n">resolution</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">circle_detail</span><span class="p">,</span>
                           <span class="n">join_style</span><span class="o">=</span><span class="n">join</span><span class="p">,</span> <span class="n">mitre_limit</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">outlines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">p1</span><span class="p">)</span>

    <span class="c1"># print(outlines)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">dont_merge</span><span class="p">:</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">sgeometry</span><span class="o">.</span><span class="n">MultiPolygon</span><span class="p">(</span><span class="n">outlines</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">outline</span> <span class="o">=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">unary_union</span><span class="p">(</span><span class="n">outlines</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">outline</span></div>



<div class="viewcode-block" id="addOrientationObject">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.addOrientationObject">[docs]</a>
<span class="k">def</span> <span class="nf">addOrientationObject</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Set up orientation for a milling object.</span>

<span class="sd">    This function creates an orientation object in the Blender scene for</span>
<span class="sd">    4-axis and 5-axis milling operations. It checks if an orientation object</span>
<span class="sd">    with the specified name already exists, and if not, it adds a new empty</span>
<span class="sd">    object of type &#39;ARROWS&#39;. The function then configures the rotation locks</span>
<span class="sd">    and initial rotation angles based on the specified machine axes and</span>
<span class="sd">    rotary axis.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing properties such as name,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; orientation&#39;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">empty_add</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ARROWS&#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;WORLD&#39;</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">empty_draw_size</span> <span class="o">=</span> <span class="mf">0.05</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">show_name</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">machine_axes</span> <span class="o">==</span> <span class="s1">&#39;4&#39;</span><span class="p">:</span>

        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">rotary_axis_1</span> <span class="o">==</span> <span class="s1">&#39;X&#39;</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">lock_rotation</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">rotary_axis_1</span> <span class="o">==</span> <span class="s1">&#39;Y&#39;</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">lock_rotation</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">rotary_axis_1</span> <span class="o">==</span> <span class="s1">&#39;Z&#39;</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">lock_rotation</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">]</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">o</span><span class="o">.</span><span class="n">machine_axes</span> <span class="o">==</span> <span class="s1">&#39;5&#39;</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">lock_rotation</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">]</span>

        <span class="n">ob</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># this will be a bit hard to rotate.....</span></div>



<span class="c1"># def addCutterOrientationObject(o):</span>


<div class="viewcode-block" id="removeOrientationObject">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.removeOrientationObject">[docs]</a>
<span class="k">def</span> <span class="nf">removeOrientationObject</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Remove an orientation object from the current Blender scene.</span>

<span class="sd">    This function constructs the name of the orientation object based on the</span>
<span class="sd">    name of the provided object and attempts to find and delete it from the</span>
<span class="sd">    Blender scene. If the orientation object exists, it will be removed</span>
<span class="sd">    using the `delob` function.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (Object): The object whose orientation object is to be removed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
  <span class="c1"># not working</span>
    <span class="n">name</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; orientation&#39;</span>
    <span class="k">if</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="n">delob</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span></div>



<div class="viewcode-block" id="addTranspMat">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.addTranspMat">[docs]</a>
<span class="k">def</span> <span class="nf">addTranspMat</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">mname</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a transparent material to a given object.</span>

<span class="sd">    This function checks if a material with the specified name already</span>
<span class="sd">    exists in the Blender data. If it does, it retrieves that material; if</span>
<span class="sd">    not, it creates a new material with the given name and enables the use</span>
<span class="sd">    of nodes. The function then assigns the material to the specified</span>
<span class="sd">    object, ensuring that it is applied correctly whether the object already</span>
<span class="sd">    has materials or not.</span>

<span class="sd">    Args:</span>
<span class="sd">        ob (bpy.types.Object): The Blender object to which the material will be assigned.</span>
<span class="sd">        mname (str): The name of the material to be added or retrieved.</span>
<span class="sd">        color (tuple): The RGBA color value for the material (not used in this function).</span>
<span class="sd">        alpha (float): The transparency value for the material (not used in this function).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">mname</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="n">mname</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="n">mname</span><span class="p">)</span>
        <span class="n">mat</span><span class="o">.</span><span class="n">use_nodes</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">bsdf</span> <span class="o">=</span> <span class="n">mat</span><span class="o">.</span><span class="n">node_tree</span><span class="o">.</span><span class="n">nodes</span><span class="p">[</span><span class="s2">&quot;Principled BSDF&quot;</span><span class="p">]</span>

        <span class="c1"># Assign it to object</span>
        <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">materials</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">materials</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">mat</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">materials</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span></div>



<div class="viewcode-block" id="addMachineAreaObject">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.addMachineAreaObject">[docs]</a>
<span class="k">def</span> <span class="nf">addMachineAreaObject</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a machine area object to the current Blender scene.</span>

<span class="sd">    This function checks if a machine object named &#39;CAM_machine&#39; already</span>
<span class="sd">    exists in the current scene. If it does not exist, it creates a new cube</span>
<span class="sd">    mesh object, applies transformations, and modifies its geometry to</span>
<span class="sd">    represent a machine area. The function ensures that the scene&#39;s unit</span>
<span class="sd">    settings are set to metric before creating the object and restores the</span>
<span class="sd">    original unit settings afterward. It also configures the display</span>
<span class="sd">    properties of the object for better visibility in the scene.  The</span>
<span class="sd">    function operates within Blender&#39;s context and utilizes various Blender</span>
<span class="sd">    operations to create and modify the mesh. It also handles the selection</span>
<span class="sd">    state of the active object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">ao</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CAM_machine&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;CAM_machine&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">oldunits</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unit_settings</span><span class="o">.</span><span class="n">system</span>
        <span class="n">oldLengthUnit</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">unit_settings</span><span class="o">.</span><span class="n">length_unit</span>
        <span class="c1"># need to be in metric units when adding machine mesh object</span>
        <span class="c1"># in order for location to work properly</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unit_settings</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="s1">&#39;METRIC&#39;</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">primitive_cube_add</span><span class="p">(</span>
            <span class="n">align</span><span class="o">=</span><span class="s1">&#39;WORLD&#39;</span><span class="p">,</span> <span class="n">enter_editmode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
        <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CAM_machine&#39;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CAM_machine&#39;</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">transform_apply</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># o.type = &#39;SOLID&#39;</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">editmode_toggle</span><span class="p">()</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;ONLY_FACE&#39;</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">select_mode</span><span class="p">(</span><span class="n">use_extend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">use_expand</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="s1">&#39;EDGE&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;TOGGLE&#39;</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">select_all</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;TOGGLE&#39;</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">subdivide</span><span class="p">(</span><span class="n">number_cuts</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span> <span class="n">smoothness</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">quadcorner</span><span class="o">=</span><span class="s1">&#39;STRAIGHT_CUT&#39;</span><span class="p">,</span> <span class="n">fractal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                               <span class="n">fractal_along_normal</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">select_nth</span><span class="p">(</span><span class="n">nth</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;EDGE&#39;</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">primitive_cube_add</span><span class="p">(</span>
            <span class="n">align</span><span class="o">=</span><span class="s1">&#39;WORLD&#39;</span><span class="p">,</span> <span class="n">enter_editmode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">editmode_toggle</span><span class="p">()</span>
        <span class="c1"># addTranspMat(o, &quot;violet_transparent&quot;, (0.800000, 0.530886, 0.725165), 0.1)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">display_type</span> <span class="o">=</span> <span class="s1">&#39;BOUNDS&#39;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">hide_render</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">o</span><span class="o">.</span><span class="n">hide_select</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># o.select = False</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unit_settings</span><span class="o">.</span><span class="n">system</span> <span class="o">=</span> <span class="n">oldunits</span>
        <span class="n">s</span><span class="o">.</span><span class="n">unit_settings</span><span class="o">.</span><span class="n">length_unit</span> <span class="o">=</span> <span class="n">oldLengthUnit</span>

    <span class="c1"># bpy.ops.wm.redraw_timer(type=&#39;DRAW_WIN_SWAP&#39;, iterations=1)</span>

    <span class="n">o</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_machine</span><span class="o">.</span><span class="n">working_area</span>
    <span class="k">if</span> <span class="n">ao</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ao</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># else:</span>
    <span class="c1">#     bpy.context.scene.objects.active = None</span>


<div class="viewcode-block" id="addMaterialAreaObject">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.addMaterialAreaObject">[docs]</a>
<span class="k">def</span> <span class="nf">addMaterialAreaObject</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a material area object to the current Blender scene.</span>

<span class="sd">    This function checks if a material area object named &#39;CAM_material&#39;</span>
<span class="sd">    already exists in the current scene. If it does, it retrieves that</span>
<span class="sd">    object; if not, it creates a new cube mesh object to serve as the</span>
<span class="sd">    material area. The dimensions and location of the object are set based</span>
<span class="sd">    on the current camera operation&#39;s bounds. The function also applies</span>
<span class="sd">    transformations to ensure the object&#39;s location and dimensions are</span>
<span class="sd">    correctly set.  The created or retrieved object is configured to be non-</span>
<span class="sd">    renderable and non-selectable in the viewport, while still being</span>
<span class="sd">    selectable for operations. This is useful for visualizing the working</span>
<span class="sd">    area of the camera without affecting the render output.  Raises:</span>
<span class="sd">    None</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">operation</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">getOperationSources</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>
    <span class="n">getBounds</span><span class="p">(</span><span class="n">operation</span><span class="p">)</span>

    <span class="n">ao</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CAM_material&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;CAM_material&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">mesh</span><span class="o">.</span><span class="n">primitive_cube_add</span><span class="p">(</span>
            <span class="n">align</span><span class="o">=</span><span class="s1">&#39;WORLD&#39;</span><span class="p">,</span> <span class="n">enter_editmode</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">location</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">rotation</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
        <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CAM_material&#39;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CAM_material&#39;</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">transform_apply</span><span class="p">(</span><span class="n">location</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># addTranspMat(o, &#39;blue_transparent&#39;, (0.458695, 0.794658, 0.8), 0.1)</span>
        <span class="n">o</span><span class="o">.</span><span class="n">display_type</span> <span class="o">=</span> <span class="s1">&#39;BOUNDS&#39;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">hide_render</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">o</span><span class="o">.</span><span class="n">hide_select</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">o</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">view_layer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
    <span class="c1"># bpy.ops.wm.redraw_timer(type=&#39;DRAW_WIN_SWAP&#39;, iterations=1)</span>

    <span class="n">o</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_machine</span><span class="o">.</span><span class="n">working_area</span>

    <span class="n">o</span><span class="o">.</span><span class="n">dimensions</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">operation</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">operation</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">operation</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span> <span class="o">-</span> <span class="n">operation</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">min</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">max</span><span class="o">.</span><span class="n">z</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ao</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ao</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span></div>

    <span class="c1"># else:</span>
    <span class="c1">#     bpy.context.scene.objects.active = None</span>


<div class="viewcode-block" id="getContainer">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getContainer">[docs]</a>
<span class="k">def</span> <span class="nf">getContainer</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get or create a container object for camera objects.</span>

<span class="sd">    This function checks if a container object named &#39;CAM_OBJECTS&#39; exists in</span>
<span class="sd">    the current Blender scene. If it does not exist, the function creates a</span>
<span class="sd">    new empty object of type &#39;PLAIN_AXES&#39;, names it &#39;CAM_OBJECTS&#39;, and sets</span>
<span class="sd">    its location to the origin (0, 0, 0). The newly created container is</span>
<span class="sd">    also hidden. If the container already exists, it simply retrieves and</span>
<span class="sd">    returns that object.</span>

<span class="sd">    Returns:</span>
<span class="sd">        bpy.types.Object: The container object for camera objects, either newly created or</span>
<span class="sd">            existing.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;CAM_OBJECTS&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">empty_add</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;PLAIN_AXES&#39;</span><span class="p">,</span> <span class="n">align</span><span class="o">=</span><span class="s1">&#39;WORLD&#39;</span><span class="p">)</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
        <span class="n">container</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;CAM_OBJECTS&#39;</span>
        <span class="n">container</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">container</span><span class="o">.</span><span class="n">hide</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">container</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s1">&#39;CAM_OBJECTS&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">container</span></div>



<span class="c1"># progress(&#39;finished&#39;)</span>

<span class="c1"># tools for voroni graphs all copied from the delaunayVoronoi addon:</span>
<div class="viewcode-block" id="Point">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.Point">[docs]</a>
<span class="k">class</span> <span class="nc">Point</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z</span> <span class="o">=</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span></div>



<div class="viewcode-block" id="unique">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.unique">[docs]</a>
<span class="k">def</span> <span class="nf">unique</span><span class="p">(</span><span class="n">L</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a list of unhashable elements in L, but without duplicates.</span>

<span class="sd">    This function processes a list of lists, specifically designed to handle</span>
<span class="sd">    unhashable elements. It sorts the input list and removes duplicates by</span>
<span class="sd">    comparing the elements based on their coordinates. The function counts</span>
<span class="sd">    the number of duplicate vertices and the number of collinear points</span>
<span class="sd">    along the Z-axis.</span>

<span class="sd">    Args:</span>
<span class="sd">        L (list): A list of lists, where each inner list represents a point</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two integers:</span>
<span class="sd">            - The first integer represents the count of duplicate vertices.</span>
<span class="sd">            - The second integer represents the count of Z-collinear points.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># For unhashable objects, you can sort the sequence and then scan from the end of the list,</span>
    <span class="c1"># deleting duplicates as you go</span>
    <span class="n">nDupli</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">nZcolinear</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># sort() brings the equal elements together; then duplicates are easy to weed out in a single pass.</span>
    <span class="n">L</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">last</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][:</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># XY coordinates compararison</span>
            <span class="k">if</span> <span class="n">last</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]:</span>  <span class="c1"># Z coordinates compararison</span>
                <span class="n">nDupli</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># duplicates vertices</span>
            <span class="k">else</span><span class="p">:</span>  <span class="c1"># Z colinear</span>
                <span class="n">nZcolinear</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">del</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">last</span> <span class="o">=</span> <span class="n">L</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">nDupli</span><span class="p">,</span>
            <span class="n">nZcolinear</span><span class="p">)</span>  <span class="c1"># list data type is mutable,</span></div>

    <span class="c1"># input list will automatically update and doesn&#39;t need to be returned</span>


<div class="viewcode-block" id="checkEqual">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.checkEqual">[docs]</a>
<span class="k">def</span> <span class="nf">checkEqual</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">lst</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">==</span> <span class="n">lst</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span></div>



<div class="viewcode-block" id="prepareIndexed">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.prepareIndexed">[docs]</a>
<span class="k">def</span> <span class="nf">prepareIndexed</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Prepare and index objects in the given collection.</span>

<span class="sd">    This function stores the world matrices and parent relationships of the</span>
<span class="sd">    objects in the provided collection. It then clears the parent</span>
<span class="sd">    relationships while maintaining their transformations, sets the</span>
<span class="sd">    orientation of the objects based on a specified orientation object, and</span>
<span class="sd">    finally re-establishes the parent-child relationships with the</span>
<span class="sd">    orientation object. The function also resets the location and rotation</span>
<span class="sd">    of the orientation object to the origin.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (ObjectCollection): A collection of objects to be prepared and indexed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="c1"># first store objects positions/rotations</span>
    <span class="n">o</span><span class="o">.</span><span class="n">matrices</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">o</span><span class="o">.</span><span class="n">parents</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">matrices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">matrix_world</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">o</span><span class="o">.</span><span class="n">parents</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ob</span><span class="o">.</span><span class="n">parent</span><span class="p">)</span>

    <span class="c1"># then rotate them</span>
    <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">parent_clear</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;CLEAR_KEEP_TRANSFORM&#39;</span><span class="p">)</span>

    <span class="n">s</span><span class="o">.</span><span class="n">cursor</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">oriname</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39; orientation&#39;</span>
    <span class="n">ori</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oriname</span><span class="p">]</span>
    <span class="n">o</span><span class="o">.</span><span class="n">orientation_matrix</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">matrix_world</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">o</span><span class="o">.</span><span class="n">rotationaxes</span> <span class="o">=</span> <span class="n">rotTo2axes</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">rotation_euler</span><span class="p">,</span> <span class="s1">&#39;CA&#39;</span><span class="p">)</span>
    <span class="n">ori</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ori</span>
    <span class="c1"># we parent all objects to the orientation object</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">parent_set</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;OBJECT&#39;</span><span class="p">,</span> <span class="n">keep_transform</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># then we move the orientation object to 0,0</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">location_clear</span><span class="p">()</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">rotation_clear</span><span class="p">()</span>
    <span class="n">ori</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">o</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
        <span class="n">activate</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>

        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">parent_clear</span><span class="p">(</span><span class="nb">type</span><span class="o">=</span><span class="s1">&#39;CLEAR_KEEP_TRANSFORM&#39;</span><span class="p">)</span></div>


    <span class="c1"># rot=ori.matrix_world.inverted()</span>
    <span class="c1"># #rot.x=-rot.x</span>
    <span class="c1"># #rot.y=-rot.y</span>
    <span class="c1"># #rot.z=-rot.z</span>
    <span class="c1"># rotationaxes = rotTo2axes(ori.rotation_euler,&#39;CA&#39;)</span>
    <span class="c1">#</span>
    <span class="c1"># #bpy.context.space_data.pivot_point = &#39;CURSOR&#39;</span>
    <span class="c1"># #bpy.context.space_data.pivot_point = &#39;CURSOR&#39;</span>
    <span class="c1">#</span>
    <span class="c1"># for ob in o.objects:</span>
    <span class="c1">#     ob.rotation_euler.rotate(rot)</span>


<div class="viewcode-block" id="cleanupIndexed">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.cleanupIndexed">[docs]</a>
<span class="k">def</span> <span class="nf">cleanupIndexed</span><span class="p">(</span><span class="n">operation</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Clean up indexed operations by updating object orientations and paths.</span>

<span class="sd">    This function takes an operation object and updates the orientation of a</span>
<span class="sd">    specified object in the scene based on the provided orientation matrix.</span>
<span class="sd">    It also sets the location and rotation of a camera path object to match</span>
<span class="sd">    the updated orientation. Additionally, it reassigns parent-child</span>
<span class="sd">    relationships for the objects involved in the operation and updates</span>
<span class="sd">    their world matrices.</span>

<span class="sd">    Args:</span>
<span class="sd">        operation (OperationType): An object containing the necessary data</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">oriname</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;orientation&#39;</span>

    <span class="n">ori</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oriname</span><span class="p">]</span>
    <span class="n">path</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="s2">&quot;cam_path_</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">name</span><span class="p">)]</span>

    <span class="n">ori</span><span class="o">.</span><span class="n">matrix_world</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">orientation_matrix</span>
    <span class="c1"># set correct path location</span>
    <span class="n">path</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">location</span>
    <span class="n">path</span><span class="o">.</span><span class="n">rotation_euler</span> <span class="o">=</span> <span class="n">ori</span><span class="o">.</span><span class="n">rotation_euler</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">ori</span><span class="o">.</span><span class="n">matrix_world</span><span class="p">,</span> <span class="n">operation</span><span class="o">.</span><span class="n">orientation_matrix</span><span class="p">)</span>
    <span class="c1"># TODO: fix this here wrong order can cause objects out of place</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">parents</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ob</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">operation</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">matrix_world</span> <span class="o">=</span> <span class="n">operation</span><span class="o">.</span><span class="n">matrices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>



<div class="viewcode-block" id="rotTo2axes">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.rotTo2axes">[docs]</a>
<span class="k">def</span> <span class="nf">rotTo2axes</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">axescombination</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Converts an Orientation Object Rotation to Rotation Defined by 2</span>
<span class="sd">    Rotational Axes on the Machine.</span>

<span class="sd">    This function takes an orientation object and a specified axes</span>
<span class="sd">    combination, and computes the angles of rotation around two axes based</span>
<span class="sd">    on the provided orientation. It supports different axes combinations for</span>
<span class="sd">    indexed machining. The function utilizes vector mathematics to determine</span>
<span class="sd">    the angles of rotation and returns them as a tuple.</span>

<span class="sd">    Args:</span>
<span class="sd">        e (OrientationObject): The orientation object representing the rotation.</span>
<span class="sd">        axescombination (str): A string indicating the axes combination (&#39;CA&#39; or &#39;CB&#39;).</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing two angles (float) representing the rotation</span>
<span class="sd">        around the specified axes.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">v</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="c1"># if axes</span>
    <span class="k">if</span> <span class="n">axescombination</span> <span class="o">==</span> <span class="s1">&#39;CA&#39;</span><span class="p">:</span>
        <span class="n">v2d</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="c1"># ?is this right?It should be vector defining 0 rotation</span>
        <span class="n">a1base</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">v2d</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cangle</span> <span class="o">=</span> <span class="n">a1base</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">v2d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">v2d</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">v2d</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="n">a2base</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">aangle</span> <span class="o">=</span> <span class="n">a2base</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">v2d</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="n">cangle</span><span class="p">,</span> <span class="n">aangle</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cangle</span><span class="p">,</span> <span class="n">aangle</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">axescombination</span> <span class="o">==</span> <span class="s1">&#39;CB&#39;</span><span class="p">:</span>
        <span class="n">v2d</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">v</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="c1"># ?is this right?It should be vector defining 0 rotation</span>
        <span class="n">a1base</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">v2d</span><span class="o">.</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">cangle</span> <span class="o">=</span> <span class="n">a1base</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">v2d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">v2d</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="n">v2d</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">v</span><span class="o">.</span><span class="n">z</span><span class="p">))</span>
        <span class="n">a2base</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="n">bangle</span> <span class="o">=</span> <span class="n">a2base</span><span class="o">.</span><span class="n">angle_signed</span><span class="p">(</span><span class="n">v2d</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;angles&#39;</span><span class="p">,</span> <span class="n">cangle</span><span class="p">,</span> <span class="n">bangle</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">cangle</span><span class="p">,</span> <span class="n">bangle</span><span class="p">)</span></div>


    <span class="c1"># v2d=((v[a[0]],v[a[1]]))</span>
    <span class="c1"># angle1=a1base.angle(v2d)#C for ca</span>
    <span class="c1"># print(angle1)</span>
    <span class="c1"># if axescombination[0]==&#39;C&#39;:</span>
    <span class="c1">#     e1=Vector((0,0,-angle1))</span>
    <span class="c1"># elif axescombination[0]==&#39;A&#39;:#TODO: finish this after prototyping stage</span>
    <span class="c1">#     pass;</span>
    <span class="c1"># v.rotate(e1)</span>
    <span class="c1"># vbase=Vector(0,1,0)</span>
    <span class="c1"># bangle=v.angle(vzbase)</span>
    <span class="c1"># print(v)</span>
    <span class="c1"># print(bangle)</span>

    <span class="c1"># return (angle1, angle2)</span>


<div class="viewcode-block" id="reload_paths">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.reload_paths">[docs]</a>
<span class="k">def</span> <span class="nf">reload_paths</span><span class="p">(</span><span class="n">o</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Reload the camera path data from a pickle file.</span>

<span class="sd">    This function retrieves the camera path data associated with the given</span>
<span class="sd">    object `o`. It constructs a new mesh from the path vertices and updates</span>
<span class="sd">    the object&#39;s properties with the loaded data. If a previous path mesh</span>
<span class="sd">    exists, it is removed to avoid memory leaks. The function also handles</span>
<span class="sd">    the creation of a new mesh object if one does not already exist in the</span>
<span class="sd">    current scene.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (Object): The object for which the camera path is being</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">oname</span> <span class="o">=</span> <span class="s2">&quot;cam_path_&quot;</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="c1"># for o in s.objects:</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">old_pathmesh</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">oname</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
        <span class="n">old_pathmesh</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oname</span><span class="p">]</span><span class="o">.</span><span class="n">data</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oname</span><span class="p">]</span>

    <span class="n">picklepath</span> <span class="o">=</span> <span class="n">getCachePath</span><span class="p">(</span><span class="n">o</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.pickle&#39;</span>
    <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">picklepath</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="c1"># passed=False</span>
    <span class="c1"># while not passed:</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         f=open(picklepath,&#39;rb&#39;)</span>
    <span class="c1">#         d=pickle.load(f)</span>
    <span class="c1">#         f.close()</span>
    <span class="c1">#         passed=True</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         print(&#39;sleep&#39;)</span>
    <span class="c1">#         time.sleep(1)</span>

    <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">warnings</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;warnings&#39;</span><span class="p">]</span>
    <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">duration</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span>
    <span class="n">verts</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="s1">&#39;path&#39;</span><span class="p">]</span>

    <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
        <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">oname</span> <span class="o">=</span> <span class="s2">&quot;cam_path_&quot;</span> <span class="o">+</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span>
    <span class="n">mesh</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">meshes</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">oname</span><span class="p">)</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">oname</span>
    <span class="n">mesh</span><span class="o">.</span><span class="n">from_pydata</span><span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="p">[])</span>

    <span class="k">if</span> <span class="n">oname</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
        <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oname</span><span class="p">]</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">mesh</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">object_utils</span><span class="o">.</span><span class="n">object_data_add</span><span class="p">(</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">mesh</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">oname</span>
    <span class="n">ob</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">oname</span><span class="p">]</span>
    <span class="n">ob</span><span class="o">.</span><span class="n">location</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">path_object_name</span> <span class="o">=</span> <span class="n">oname</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">old_pathmesh</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">meshes</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">old_pathmesh</span><span class="p">)</span></div>



<span class="c1"># def setup_operation_preset():</span>
<span class="c1">#     scene = bpy.context.scene</span>
<span class="c1">#     cam_operations = scene.cam_operations</span>
<span class="c1">#     active_operation = scene.cam_active_operation</span>
<span class="c1">#     try:</span>
<span class="c1">#         o = cam_operations[active_operation]</span>
<span class="c1">#     except IndexError:</span>
<span class="c1">#         bpy.ops.scene.cam_operation_add()</span>
<span class="c1">#         o = cam_operations[active_operation]</span>
<span class="c1">#     return o</span>


<span class="c1"># Moved from init - the following code was moved here to permit the import fix</span>
<div class="viewcode-block" id="USE_PROFILER">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.USE_PROFILER">[docs]</a>
<span class="n">USE_PROFILER</span> <span class="o">=</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="was_hidden_dict">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.was_hidden_dict">[docs]</a>
<span class="n">was_hidden_dict</span> <span class="o">=</span> <span class="p">{}</span></div>


<div class="viewcode-block" id="_IS_LOADING_DEFAULTS">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam._IS_LOADING_DEFAULTS">[docs]</a>
<span class="n">_IS_LOADING_DEFAULTS</span> <span class="o">=</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="updateMachine">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateMachine">[docs]</a>
<span class="k">def</span> <span class="nf">updateMachine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the machine with the given context.</span>

<span class="sd">    This function is responsible for updating the machine state based on the</span>
<span class="sd">    provided context. It prints a message indicating that the update process</span>
<span class="sd">    has started. If the global variable _IS_LOADING_DEFAULTS is not set to</span>
<span class="sd">    True, it proceeds to add a machine area object.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the machine update is being performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Machine&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">_IS_LOADING_DEFAULTS</span><span class="p">:</span>
        <span class="n">addMachineAreaObject</span><span class="p">()</span></div>



<div class="viewcode-block" id="updateMaterial">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateMaterial">[docs]</a>
<span class="k">def</span> <span class="nf">updateMaterial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the material in the given context.</span>

<span class="sd">    This method is responsible for updating the material based on the</span>
<span class="sd">    provided context. It performs necessary operations to ensure that the</span>
<span class="sd">    material is updated correctly. Currently, it prints a message indicating</span>
<span class="sd">    the update process and calls the `addMaterialAreaObject` function to</span>
<span class="sd">    handle additional material area object updates.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the material update is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Material&#39;</span><span class="p">)</span>
    <span class="n">addMaterialAreaObject</span><span class="p">()</span></div>



<div class="viewcode-block" id="updateOperation">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateOperation">[docs]</a>
<span class="k">def</span> <span class="nf">updateOperation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the visibility and selection state of camera operations in the</span>
<span class="sd">    scene.</span>

<span class="sd">    This method manages the visibility of objects associated with camera</span>
<span class="sd">    operations based on the current active operation. If the</span>
<span class="sd">    &#39;hide_all_others&#39; flag is set to true, it hides all other objects except</span>
<span class="sd">    for the currently active one. If the flag is false, it restores the</span>
<span class="sd">    visibility of previously hidden objects. The method also attempts to</span>
<span class="sd">    highlight the currently active object in the 3D view and make it the</span>
<span class="sd">    active object in the scene.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (bpy.types.Context): The context containing the current scene and</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scene</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">ao</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">operationValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ao</span><span class="o">.</span><span class="n">hide_all_others</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">_ao</span> <span class="ow">in</span> <span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">_ao</span><span class="o">.</span><span class="n">path_object_name</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">other_obj</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">_ao</span><span class="o">.</span><span class="n">path_object_name</span><span class="p">]</span>
                <span class="n">current_obj</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">ao</span><span class="o">.</span><span class="n">path_object_name</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">other_obj</span> <span class="o">!=</span> <span class="n">current_obj</span><span class="p">:</span>
                    <span class="n">other_obj</span><span class="o">.</span><span class="n">hide</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">other_obj</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">path_obj_name</span> <span class="ow">in</span> <span class="n">was_hidden_dict</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">was_hidden_dict</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">was_hidden_dict</span><span class="p">[</span><span class="n">path_obj_name</span><span class="p">]:</span>
                <span class="c1"># Find object and make it hidde, then reset &#39;hidden&#39; flag</span>
                <span class="n">obj</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">path_obj_name</span><span class="p">]</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">hide</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">select</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">was_hidden_dict</span><span class="p">[</span><span class="n">path_obj_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># try highlighting the object in the 3d view and make it active</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">select_all</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;DESELECT&#39;</span><span class="p">)</span>
    <span class="c1"># highlight the cutting path if it exists</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">ao</span><span class="o">.</span><span class="n">path_object_name</span><span class="p">]</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">view_layer</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Show object if, it&#39;s was hidden</span>
        <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">hide</span><span class="p">:</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">hide</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">was_hidden_dict</span><span class="p">[</span><span class="n">ao</span><span class="o">.</span><span class="n">path_object_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span></div>


<span class="c1"># Moved from init - part 2</span>


<div class="viewcode-block" id="isValid">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.isValid">[docs]</a>
<span class="k">def</span> <span class="nf">isValid</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check the validity of a geometry source.</span>

<span class="sd">    This function verifies if the provided geometry source is valid based on</span>
<span class="sd">    its type. It checks for three types of geometry sources: &#39;OBJECT&#39;,</span>
<span class="sd">    &#39;COLLECTION&#39;, and &#39;IMAGE&#39;. For &#39;OBJECT&#39;, it ensures that the object name</span>
<span class="sd">    ends with &#39;_cut_bridges&#39; or exists in the Blender data objects. For</span>
<span class="sd">    &#39;COLLECTION&#39;, it checks if the collection name exists and contains</span>
<span class="sd">    objects. For &#39;IMAGE&#39;, it verifies if the source image name exists in the</span>
<span class="sd">    Blender data images.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing geometry source information, including</span>
<span class="sd">            attributes like `geometry_source`, `object_name`, `collection_name`,</span>
<span class="sd">            and `source_image_name`.</span>
<span class="sd">        context: The context in which the validation is performed (not used in this</span>
<span class="sd">            function).</span>

<span class="sd">    Returns:</span>
<span class="sd">        bool: True if the geometry source is valid, False otherwise.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">valid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;OBJECT&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">o</span><span class="o">.</span><span class="n">object_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_cut_bridges&#39;</span><span class="p">):</span>  <span class="c1"># let empty bridge cut be valid</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">object_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;COLLECTION&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">collection_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">collections</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">collections</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">collection_name</span><span class="p">]</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;IMAGE&#39;</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">source_image_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">images</span><span class="p">:</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">return</span> <span class="n">valid</span></div>



<div class="viewcode-block" id="operationValid">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.operationValid">[docs]</a>
<span class="k">def</span> <span class="nf">operationValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validate the current camera operation in the given context.</span>

<span class="sd">    This method checks if the active camera operation is valid based on the</span>
<span class="sd">    current scene context. It updates the operation&#39;s validity status and</span>
<span class="sd">    provides warnings if the source object is invalid. Additionally, it</span>
<span class="sd">    configures specific settings related to image geometry sources.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (Context): The context containing the scene and camera operations.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">scene</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">o</span> <span class="o">=</span> <span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">o</span><span class="o">.</span><span class="n">valid</span> <span class="o">=</span> <span class="n">isValid</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="n">invalidmsg</span> <span class="o">=</span> <span class="s2">&quot;Invalid Source Object for Operation.</span><span class="se">\n</span><span class="s2">&quot;</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">valid</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">warnings</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">warnings</span> <span class="o">=</span> <span class="n">invalidmsg</span>

    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">geometry_source</span> <span class="o">==</span> <span class="s1">&#39;IMAGE&#39;</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">o</span><span class="o">.</span><span class="n">update_offsetimage_tag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">o</span><span class="o">.</span><span class="n">update_zbufferimage_tag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;validity &#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="isChainValid">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.isChainValid">[docs]</a>
<span class="k">def</span> <span class="nf">isChainValid</span><span class="p">(</span><span class="n">chain</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check the validity of a chain of operations within a given context.</span>

<span class="sd">    This function verifies if all operations in the provided chain are valid</span>
<span class="sd">    according to the current scene context. It first checks if the chain</span>
<span class="sd">    contains any operations. If it does, it iterates through each operation</span>
<span class="sd">    in the chain and checks if it exists in the scene&#39;s camera operations.</span>
<span class="sd">    If an operation is not found or is deemed invalid, the function returns</span>
<span class="sd">    a tuple indicating the failure and provides an appropriate error</span>
<span class="sd">    message. If all operations are valid, it returns a success indication.</span>

<span class="sd">    Args:</span>
<span class="sd">        chain (Chain): The chain of operations to validate.</span>
<span class="sd">        context (Context): The context containing the scene and camera operations.</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: A tuple containing a boolean indicating validity and an error message</span>
<span class="sd">            (if any). The first element is True if valid, otherwise False. The</span>
<span class="sd">            second element is an error message string.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">operations</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">cho</span> <span class="ow">in</span> <span class="n">chain</span><span class="o">.</span><span class="n">operations</span><span class="p">:</span>
        <span class="n">found_op</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">so</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">so</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">cho</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                <span class="n">found_op</span> <span class="o">=</span> <span class="n">so</span>
        <span class="k">if</span> <span class="n">found_op</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Couldn&#39;t Find Operation </span><span class="si">{</span><span class="n">cho</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">isValid</span><span class="p">(</span><span class="n">found_op</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Operation </span><span class="si">{</span><span class="n">found_op</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> Is Not Valid&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span></div>



<div class="viewcode-block" id="updateOperationValid">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateOperationValid">[docs]</a>
<span class="k">def</span> <span class="nf">updateOperationValid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="n">updateOperation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></div>



<span class="c1"># Update functions start here</span>
<div class="viewcode-block" id="updateChipload">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateChipload">[docs]</a>
<span class="k">def</span> <span class="nf">updateChipload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the chipload based on feedrate, spindle RPM, and cutter</span>
<span class="sd">    parameters.</span>

<span class="sd">    This function calculates the chipload using the formula: chipload =</span>
<span class="sd">    feedrate / (spindle_rpm * cutter_flutes). It also attempts to account</span>
<span class="sd">    for chip thinning when cutting at less than 50% cutter engagement with</span>
<span class="sd">    cylindrical end mills by combining two formulas. The first formula</span>
<span class="sd">    provides the nominal chipload based on standard recommendations, while</span>
<span class="sd">    the second formula adjusts for the cutter diameter and distance between</span>
<span class="sd">    paths.  The current implementation may not yield consistent results, and</span>
<span class="sd">    there are concerns regarding the correctness of the units used in the</span>
<span class="sd">    calculations. Further review and refinement of this function may be</span>
<span class="sd">    necessary to improve accuracy and reliability.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the update is performed (not used in this</span>
<span class="sd">            implementation).</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function does not return a value; it updates the chipload in place.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Chipload &#39;</span><span class="p">)</span>
    <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span>
    <span class="c1"># Old chipload</span>
    <span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">chipload</span> <span class="o">=</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">feedrate</span> <span class="o">/</span> <span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">spindle_rpm</span> <span class="o">*</span> <span class="n">o</span><span class="o">.</span><span class="n">cutter_flutes</span><span class="p">))</span>
    <span class="c1"># New chipload with chip thining compensation.</span>
    <span class="c1"># I have tried to combine these 2 formulas to compinsate for the phenomenon of chip thinning when cutting at less</span>
    <span class="c1"># than 50% cutter engagement with cylindrical end mills. formula 1 Nominal Chipload is</span>
    <span class="c1"># &quot; feedrate mm/minute = spindle rpm x chipload x cutter diameter mm x cutter_flutes &quot;</span>
    <span class="c1"># formula 2 (.5*(cutter diameter mm devided by dist_between_paths)) divided by square root of</span>
    <span class="c1"># ((cutter diameter mm devided by dist_between_paths)-1) x Nominal Chipload</span>
    <span class="c1"># Nominal Chipload = what you find in end mill data sheats recomended chip load at %50 cutter engagment.</span>
    <span class="c1"># I am sure there is a better way to do this. I dont get consistent result and</span>
    <span class="c1"># I am not sure if there is something wrong with the units going into the formula, my math or my lack of</span>
    <span class="c1"># underestanding of python or programming in genereal. Hopefuly some one can have a look at this and with any luck</span>
    <span class="c1"># we will be one tiny step on the way to a slightly better chipload calculating function.</span>

    <span class="c1"># self.chipload = ((0.5*(o.cutter_diameter/o.dist_between_paths))/(sqrt((o.feedrate*1000)/(o.spindle_rpm*o.cutter_diameter*o.cutter_flutes)*(o.cutter_diameter/o.dist_between_paths)-1)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">chipload</span><span class="p">)</span></div>



<div class="viewcode-block" id="updateOffsetImage">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateOffsetImage">[docs]</a>
<span class="k">def</span> <span class="nf">updateOffsetImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Refresh the Offset Image Tag for re-rendering.</span>

<span class="sd">    This method updates the chip load and marks the offset image tag for re-</span>
<span class="sd">    rendering. It sets the `changed` attribute to True and indicates that</span>
<span class="sd">    the offset image tag needs to be updated.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the update is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">updateChipload</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Offset&#39;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_offsetimage_tag</span> <span class="o">=</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="updateZbufferImage">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateZbufferImage">[docs]</a>
<span class="k">def</span> <span class="nf">updateZbufferImage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the Z-buffer and offset image tags for recalculation.</span>

<span class="sd">    This method modifies the internal state to indicate that the Z-buffer</span>
<span class="sd">    image and offset image tags need to be updated during the calculation</span>
<span class="sd">    process. It sets the `changed` attribute to True and marks the relevant</span>
<span class="sd">    tags for updating. Additionally, it calls the `getOperationSources`</span>
<span class="sd">    function to ensure that the necessary operation sources are retrieved.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the update is being performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># print(&#39;updatezbuf&#39;)</span>
    <span class="c1"># print(self,context)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_zbufferimage_tag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">update_offsetimage_tag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">getOperationSources</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>



<div class="viewcode-block" id="updateStrategy">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateStrategy">[docs]</a>
<span class="k">def</span> <span class="nf">updateStrategy</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the strategy of the given object.</span>

<span class="sd">    This function modifies the state of the object `o` by setting its</span>
<span class="sd">    `changed` attribute to True and printing a message indicating that the</span>
<span class="sd">    strategy is being updated. Depending on the value of `machine_axes` and</span>
<span class="sd">    `strategy4axis`, it either adds or removes an orientation object</span>
<span class="sd">    associated with `o`. Finally, it calls the `updateExact` function to</span>
<span class="sd">    perform further updates based on the provided context.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): The object whose strategy is to be updated.</span>
<span class="sd">        context (object): The context in which the update is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Strategy&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">machine_axes</span> <span class="o">==</span> <span class="s1">&#39;5&#39;</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="n">o</span><span class="o">.</span><span class="n">machine_axes</span> <span class="o">==</span> <span class="s1">&#39;4&#39;</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy4axis</span> <span class="o">==</span> <span class="s1">&#39;INDEXED&#39;</span><span class="p">):</span>  <span class="c1"># INDEXED 4 AXIS DOESN&#39;T EXIST NOW...</span>
        <span class="n">addOrientationObject</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">removeOrientationObject</span><span class="p">(</span><span class="n">o</span><span class="p">)</span>
    <span class="n">updateExact</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">)</span></div>



<div class="viewcode-block" id="updateCutout">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateCutout">[docs]</a>
<span class="k">def</span> <span class="nf">updateCutout</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="k">pass</span></div>



<div class="viewcode-block" id="updateExact">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateExact">[docs]</a>
<span class="k">def</span> <span class="nf">updateExact</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the state of an object for exact operations.</span>

<span class="sd">    This function modifies the properties of the given object `o` to</span>
<span class="sd">    indicate that an update is required. It sets various flags related to</span>
<span class="sd">    the object&#39;s state and checks the optimization settings. If the</span>
<span class="sd">    optimization is set to use exact mode, it further checks the strategy</span>
<span class="sd">    and inverse properties to determine if exact mode can be used. If not,</span>
<span class="sd">    it disables the use of OpenCamLib.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): The object to be updated, which contains properties related</span>
<span class="sd">        context (object): The context in which the update is being performed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function does not return a value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Exact &#39;</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">o</span><span class="o">.</span><span class="n">update_zbufferimage_tag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">o</span><span class="o">.</span><span class="n">update_offsetimage_tag</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;POCKET&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;MEDIAL_AXIS&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">inverse</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current Operation Cannot Use Exact Mode&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="o">=</span> <span class="kc">False</span></div>



<div class="viewcode-block" id="updateOpencamlib">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateOpencamlib">[docs]</a>
<span class="k">def</span> <span class="nf">updateOpencamlib</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the OpenCAMLib settings for a given operation.</span>

<span class="sd">    This function modifies the properties of the provided operation object</span>
<span class="sd">    based on its current strategy and optimization settings. If the</span>
<span class="sd">    operation&#39;s strategy is either &#39;POCKET&#39; or &#39;MEDIAL_AXIS&#39;, and if</span>
<span class="sd">    OpenCAMLib is being used for optimization, it disables the use of both</span>
<span class="sd">    exact optimization and OpenCAMLib, indicating that the current operation</span>
<span class="sd">    cannot utilize OpenCAMLib.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): The operation object containing optimization and strategy settings.</span>
<span class="sd">        context (object): The context in which the operation is being updated.</span>

<span class="sd">    Returns:</span>
<span class="sd">        None: This function does not return any value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update OpenCAMLib &#39;</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="ow">and</span> <span class="p">(</span>
            <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;POCKET&#39;</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">==</span> <span class="s1">&#39;MEDIAL_AXIS&#39;</span><span class="p">):</span>
        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_exact</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">o</span><span class="o">.</span><span class="n">optimisation</span><span class="o">.</span><span class="n">use_opencamlib</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Current Operation Cannot Use OpenCAMLib&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="updateBridges">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateBridges">[docs]</a>
<span class="k">def</span> <span class="nf">updateBridges</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the status of bridges.</span>

<span class="sd">    This function marks the bridge object as changed, indicating that an</span>
<span class="sd">    update has occurred. It prints a message to the console for logging</span>
<span class="sd">    purposes. The function takes in an object and a context, but the context</span>
<span class="sd">    is not utilized within the function.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): The bridge object that needs to be updated.</span>
<span class="sd">        context (object): Additional context for the update, not used in this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Bridges &#39;</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span></div>



<div class="viewcode-block" id="updateRotation">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateRotation">[docs]</a>
<span class="k">def</span> <span class="nf">updateRotation</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the rotation of a specified object in Blender.</span>

<span class="sd">    This function modifies the rotation of a Blender object based on the</span>
<span class="sd">    properties of the provided object &#39;o&#39;. It checks which rotations are</span>
<span class="sd">    enabled and applies the corresponding rotation values to the active</span>
<span class="sd">    object in the scene. The rotation can be aligned either along the X or Y</span>
<span class="sd">    axis, depending on the configuration of &#39;o&#39;.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): An object containing rotation settings and flags.</span>
<span class="sd">        context (object): The context in which the operation is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Rotation&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_B</span> <span class="ow">or</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_A</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span><span class="p">)</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="n">object_name</span><span class="p">]</span>
        <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">A_along_x</span><span class="p">:</span>  <span class="c1"># A parallel with X</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_A</span><span class="p">:</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_B</span><span class="p">:</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_B</span>
        <span class="k">else</span><span class="p">:</span>  <span class="c1"># A parallel with Y</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_A</span><span class="p">:</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_A</span>
            <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">enable_B</span><span class="p">:</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">rotation_euler</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">rotation_B</span></div>



<span class="c1"># def updateRest(o, context):</span>
<span class="c1">#    print(&#39;update rest &#39;)</span>
<span class="c1">#    # if o.use_layers:</span>
<span class="c1"># o.movement.parallel_step_back = False</span>
<span class="c1">#    o.changed = True</span>

<div class="viewcode-block" id="updateRest">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.updateRest">[docs]</a>
<span class="k">def</span> <span class="nf">updateRest</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the state of the object.</span>

<span class="sd">    This function modifies the given object by setting its &#39;changed&#39;</span>
<span class="sd">    attribute to True. It also prints a message indicating that the update</span>
<span class="sd">    operation has been performed.</span>

<span class="sd">    Args:</span>
<span class="sd">        o (object): The object to be updated.</span>
<span class="sd">        context (object): The context in which the update is being performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Update Rest &#39;</span><span class="p">)</span>
    <span class="n">o</span><span class="o">.</span><span class="n">changed</span> <span class="o">=</span> <span class="kc">True</span></div>



<span class="c1">#    if (o.strategy == &#39;WATERLINE&#39;):</span>
<span class="c1">#        o.use_layers = True</span>


<div class="viewcode-block" id="getStrategyList">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.getStrategyList">[docs]</a>
<span class="k">def</span> <span class="nf">getStrategyList</span><span class="p">(</span><span class="n">scene</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get a list of available strategies for operations.</span>

<span class="sd">    This function retrieves a predefined list of operation strategies that</span>
<span class="sd">    can be used in the context of a 3D scene. Each strategy is represented</span>
<span class="sd">    as a tuple containing an identifier, a user-friendly name, and a</span>
<span class="sd">    description of the operation. The list includes various operations such</span>
<span class="sd">    as cutouts, pockets, drilling, and more. If experimental features are</span>
<span class="sd">    enabled in the preferences, additional experimental strategies may be</span>
<span class="sd">    included in the returned list.</span>

<span class="sd">    Args:</span>
<span class="sd">        scene: The current scene context.</span>
<span class="sd">        context: The current context in which the operation is being performed.</span>

<span class="sd">    Returns:</span>
<span class="sd">        list: A list of tuples, each containing the strategy identifier,</span>
<span class="sd">            name, and description.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">use_experimental</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">addons</span><span class="p">[</span><span class="n">__package__</span><span class="p">]</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">experimental</span>
    <span class="n">items</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="s1">&#39;CUTOUT&#39;</span><span class="p">,</span> <span class="s1">&#39;Profile(Cutout)&#39;</span><span class="p">,</span> <span class="s1">&#39;Cut the silhouete with offset&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;POCKET&#39;</span><span class="p">,</span> <span class="s1">&#39;Pocket&#39;</span><span class="p">,</span> <span class="s1">&#39;Pocket operation&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;DRILL&#39;</span><span class="p">,</span> <span class="s1">&#39;Drill&#39;</span><span class="p">,</span> <span class="s1">&#39;Drill operation&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;PARALLEL&#39;</span><span class="p">,</span> <span class="s1">&#39;Parallel&#39;</span><span class="p">,</span> <span class="s1">&#39;Parallel lines on any angle&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CROSS&#39;</span><span class="p">,</span> <span class="s1">&#39;Cross&#39;</span><span class="p">,</span> <span class="s1">&#39;Cross paths&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;BLOCK&#39;</span><span class="p">,</span> <span class="s1">&#39;Block&#39;</span><span class="p">,</span> <span class="s1">&#39;Block path&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;SPIRAL&#39;</span><span class="p">,</span> <span class="s1">&#39;Spiral&#39;</span><span class="p">,</span> <span class="s1">&#39;Spiral path&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CIRCLES&#39;</span><span class="p">,</span> <span class="s1">&#39;Circles&#39;</span><span class="p">,</span> <span class="s1">&#39;Circles path&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;OUTLINEFILL&#39;</span><span class="p">,</span> <span class="s1">&#39;Outline Fill&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Detect outline and fill it with paths as pocket. Then sample these paths on the 3d surface&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CARVE&#39;</span><span class="p">,</span> <span class="s1">&#39;Project curve to surface&#39;</span><span class="p">,</span> <span class="s1">&#39;Engrave the curve path to surface&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;WATERLINE&#39;</span><span class="p">,</span> <span class="s1">&#39;Waterline - Roughing -below zero&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Waterline paths - constant z below zero&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;CURVE&#39;</span><span class="p">,</span> <span class="s1">&#39;Curve to Path&#39;</span><span class="p">,</span> <span class="s1">&#39;Curve object gets converted directly to path&#39;</span><span class="p">),</span>
        <span class="p">(</span><span class="s1">&#39;MEDIAL_AXIS&#39;</span><span class="p">,</span> <span class="s1">&#39;Medial axis&#39;</span><span class="p">,</span>
         <span class="s1">&#39;Medial axis, must be used with V or ball cutter, for engraving various width shapes with a single stroke &#39;</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="c1">#   if use_experimental:</span>
    <span class="c1">#       items.extend([(&#39;MEDIAL_AXIS&#39;, &#39;Medial axis - EXPERIMENTAL&#39;,</span>
    <span class="c1">#                      &#39;Medial axis, must be used with V or ball cutter, for engraving various width shapes with a single stroke &#39;)]);</span>
    <span class="c1"># (&#39;PENCIL&#39;, &#39;Pencil - EXPERIMENTAL&#39;,&#39;Pencil operation - detects negative corners in the model and mills only those.&#39;),</span>
    <span class="c1"># (&#39;CRAZY&#39;, &#39;Crazy path - EXPERIMENTAL&#39;, &#39;Crazy paths - dont even think about using this!&#39;),</span>
    <span class="c1">#                     (&#39;PROJECTED_CURVE&#39;, &#39;Projected curve - EXPERIMENTAL&#39;, &#39;project 1 curve towards other curve&#39;)])</span>
    <span class="k">return</span> <span class="n">items</span></div>


<span class="c1"># The following functions are temporary</span>
<span class="c1"># until all content in __init__.py is cleaned up</span>


<div class="viewcode-block" id="update_material">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.update_material">[docs]</a>
<span class="k">def</span> <span class="nf">update_material</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
    <span class="n">addMaterialAreaObject</span><span class="p">()</span></div>



<div class="viewcode-block" id="update_operation">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.update_operation">[docs]</a>
<span class="k">def</span> <span class="nf">update_operation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the camera operation based on the current context.</span>

<span class="sd">    This function retrieves the active camera operation from the Blender</span>
<span class="sd">    context and updates it using the `updateRest` function. It accesses the</span>
<span class="sd">    active operation from the scene&#39;s camera operations and passes the</span>
<span class="sd">    current context to the updating function.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the operation is being updated.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># from . import updateRest</span>
    <span class="n">active_op</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">updateRest</span><span class="p">(</span><span class="n">active_op</span><span class="p">,</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>



<div class="viewcode-block" id="update_exact_mode">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.update_exact_mode">[docs]</a>
<span class="k">def</span> <span class="nf">update_exact_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the exact mode of the active camera operation.</span>

<span class="sd">    This function retrieves the currently active camera operation from the</span>
<span class="sd">    Blender context and updates its exact mode using the `updateExact`</span>
<span class="sd">    function. It accesses the active operation through the `cam_operations`</span>
<span class="sd">    list in the current scene and passes the active operation along with the</span>
<span class="sd">    current context to the `updateExact` function.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the update is performed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># from . import updateExact</span>
    <span class="n">active_op</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">updateExact</span><span class="p">(</span><span class="n">active_op</span><span class="p">,</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>



<div class="viewcode-block" id="update_opencamlib">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.update_opencamlib">[docs]</a>
<span class="k">def</span> <span class="nf">update_opencamlib</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the OpenCamLib with the current active operation.</span>

<span class="sd">    This function retrieves the currently active camera operation from the</span>
<span class="sd">    Blender context and updates the OpenCamLib accordingly. It accesses the</span>
<span class="sd">    active operation from the scene&#39;s camera operations and passes it along</span>
<span class="sd">    with the current context to the update function.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the operation is being performed, typically</span>
<span class="sd">            provided by</span>
<span class="sd">            Blender&#39;s internal API.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># from . import updateOpencamlib</span>
    <span class="n">active_op</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">updateOpencamlib</span><span class="p">(</span><span class="n">active_op</span><span class="p">,</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>



<div class="viewcode-block" id="update_zbuffer_image">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.update_zbuffer_image">[docs]</a>
<span class="k">def</span> <span class="nf">update_zbuffer_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update the Z-buffer image based on the active camera operation.</span>

<span class="sd">    This function retrieves the currently active camera operation from the</span>
<span class="sd">    Blender context and updates the Z-buffer image accordingly. It accesses</span>
<span class="sd">    the scene&#39;s camera operations and invokes the `updateZbufferImage`</span>
<span class="sd">    function with the active operation and context.</span>

<span class="sd">    Args:</span>
<span class="sd">        context (bpy.context): The current Blender context.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># from . import updateZbufferImage</span>
    <span class="n">active_op</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span><span class="o">.</span><span class="n">cam_active_operation</span><span class="p">]</span>
    <span class="n">updateZbufferImage</span><span class="p">(</span><span class="n">active_op</span><span class="p">,</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="p">)</span></div>



<span class="c1"># Moved from init - part 3</span>

<span class="nd">@bpy</span><span class="o">.</span><span class="n">app</span><span class="o">.</span><span class="n">handlers</span><span class="o">.</span><span class="n">persistent</span>
<div class="viewcode-block" id="check_operations_on_load">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.check_operations_on_load">[docs]</a>
<span class="k">def</span> <span class="nf">check_operations_on_load</span><span class="p">(</span><span class="n">context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Checks for any broken computations on load and resets them.</span>

<span class="sd">    This function verifies the presence of necessary Blender add-ons and</span>
<span class="sd">    installs any that are missing. It also resets any ongoing computations</span>
<span class="sd">    in camera operations and sets the interface level to the previously used</span>
<span class="sd">    level when loading a new file. If the add-on has been updated, it copies</span>
<span class="sd">    the necessary presets from the source to the target directory.</span>
<span class="sd">    Additionally, it checks for updates to the camera plugin and updates</span>
<span class="sd">    operation presets if required.</span>

<span class="sd">    Args:</span>
<span class="sd">        context: The context in which the function is executed, typically containing</span>
<span class="sd">            information about</span>
<span class="sd">            the current Blender environment.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">addons</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">addons</span>

    <span class="n">addon_prefs</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">preferences</span><span class="o">.</span><span class="n">addons</span><span class="p">[</span><span class="n">__package__</span><span class="p">]</span><span class="o">.</span><span class="n">preferences</span>

    <span class="n">modules</span> <span class="o">=</span> <span class="p">[</span>
        <span class="c1"># Objects &amp; Tools</span>
        <span class="s2">&quot;extra_mesh_objects&quot;</span><span class="p">,</span>
        <span class="s2">&quot;extra_curve_objectes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;simplify_curves_plus&quot;</span><span class="p">,</span>
        <span class="s2">&quot;curve_tools&quot;</span><span class="p">,</span>
        <span class="s2">&quot;print3d_toolbox&quot;</span><span class="p">,</span>
        <span class="c1"># File Formats</span>
        <span class="s2">&quot;stl_format_legacy&quot;</span><span class="p">,</span>
        <span class="s2">&quot;import_autocad_dxf_format_dxf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;export_autocad_dxf_format_dxf&quot;</span>
    <span class="p">]</span>

    <span class="k">for</span> <span class="n">module</span> <span class="ow">in</span> <span class="n">modules</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">module</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">addons</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">addons</span><span class="p">[</span><span class="sa">f</span><span class="s1">&#39;bl_ext.blender_org.</span><span class="si">{</span><span class="n">module</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">extensions</span><span class="o">.</span><span class="n">package_install</span><span class="p">(</span><span class="n">repo_index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">pkg_id</span><span class="o">=</span><span class="n">module</span><span class="p">)</span>

    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">o</span><span class="o">.</span><span class="n">computing</span><span class="p">:</span>
            <span class="n">o</span><span class="o">.</span><span class="n">computing</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># set interface level to previously used level for a new file</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">filepath</span><span class="p">:</span>
        <span class="n">_IS_LOADING_DEFAULTS</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">s</span><span class="o">.</span><span class="n">interface</span><span class="o">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">addon_prefs</span><span class="o">.</span><span class="n">default_interface_level</span>
        <span class="n">machine_preset</span> <span class="o">=</span> <span class="n">addon_prefs</span><span class="o">.</span><span class="n">machine_preset</span> <span class="o">=</span> <span class="n">addon_prefs</span><span class="o">.</span><span class="n">default_machine_preset</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">machine_preset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Loading Preset:&quot;</span><span class="p">,</span> <span class="n">machine_preset</span><span class="p">)</span>
            <span class="c1"># load last used machine preset</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">script</span><span class="o">.</span><span class="n">execute_preset</span><span class="p">(</span>
                <span class="n">filepath</span><span class="o">=</span><span class="n">machine_preset</span><span class="p">,</span> <span class="n">menu_idname</span><span class="o">=</span><span class="s2">&quot;CAM_MACHINE_MT_presets&quot;</span>
            <span class="p">)</span>
        <span class="n">_IS_LOADING_DEFAULTS</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="c1"># check for updated version of the plugin</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">render</span><span class="o">.</span><span class="n">cam_check_updates</span><span class="p">()</span>
    <span class="c1"># copy presets if not there yet</span>
    <span class="k">if</span> <span class="n">addon_prefs</span><span class="o">.</span><span class="n">just_updated</span><span class="p">:</span>
        <span class="n">preset_source_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;presets&quot;</span>
        <span class="n">preset_target_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">bpy</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">script_path_user</span><span class="p">())</span> <span class="o">/</span> <span class="s2">&quot;presets&quot;</span>

        <span class="k">def</span> <span class="nf">copy_if_not_exists</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Copy a file from source to destination if it does not already exist.</span>

<span class="sd">            This function checks if the destination file exists. If it does not, the</span>
<span class="sd">            function copies the source file to the destination using a high-level</span>
<span class="sd">            file operation that preserves metadata.</span>

<span class="sd">            Args:</span>
<span class="sd">                src (str): The path to the source file to be copied.</span>
<span class="sd">                dst (str): The path to the destination where the file should be copied.</span>
<span class="sd">            &quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">()</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">shutil</span><span class="o">.</span><span class="n">copy2</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">dst</span><span class="p">)</span>

        <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span>
            <span class="n">preset_source_path</span><span class="p">,</span>
            <span class="n">preset_target_path</span><span class="p">,</span>
            <span class="n">copy_function</span><span class="o">=</span><span class="n">copy_if_not_exists</span><span class="p">,</span>
            <span class="n">dirs_exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">addon_prefs</span><span class="o">.</span><span class="n">just_updated</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">wm</span><span class="o">.</span><span class="n">save_userpref</span><span class="p">()</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">addon_prefs</span><span class="o">.</span><span class="n">op_preset_update</span><span class="p">:</span>
        <span class="c1"># Update the Operation presets</span>
        <span class="n">op_presets_source</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="vm">__file__</span><span class="p">)</span><span class="o">.</span><span class="n">parent</span> <span class="o">/</span> <span class="s2">&quot;presets&quot;</span> <span class="o">/</span> <span class="s2">&quot;cam_operations&quot;</span>
        <span class="n">op_presets_target</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">bpy</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">script_path_user</span><span class="p">())</span> <span class="o">/</span> <span class="s2">&quot;presets&quot;</span> <span class="o">/</span> <span class="s2">&quot;cam_operations&quot;</span>
        <span class="n">shutil</span><span class="o">.</span><span class="n">copytree</span><span class="p">(</span><span class="n">op_presets_source</span><span class="p">,</span> <span class="n">op_presets_target</span><span class="p">,</span> <span class="n">dirs_exist_ok</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">addon_prefs</span><span class="o">.</span><span class="n">op_preset_update</span> <span class="o">=</span> <span class="kc">True</span></div>



<span class="c1"># add pocket op for medial axis and profile cut inside to clean unremoved material</span>
<div class="viewcode-block" id="Add_Pocket">
<a class="viewcode-back" href="../../autoapi/cam/utils/index.html#cam.Add_Pocket">[docs]</a>
<span class="k">def</span> <span class="nf">Add_Pocket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maxdepth</span><span class="p">,</span> <span class="n">sname</span><span class="p">,</span> <span class="n">new_cutter_diameter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add a pocket operation for the medial axis and profile cut.</span>

<span class="sd">    This function first deselects all objects in the scene and then checks</span>
<span class="sd">    for any existing medial pocket objects, deleting them if found. It</span>
<span class="sd">    verifies whether a medial pocket operation already exists in the camera</span>
<span class="sd">    operations. If it does not exist, it creates a new pocket operation with</span>
<span class="sd">    the specified parameters. The function also modifies the selected</span>
<span class="sd">    object&#39;s silhouette offset based on the new cutter diameter.</span>

<span class="sd">    Args:</span>
<span class="sd">        maxdepth (float): The maximum depth of the pocket to be created.</span>
<span class="sd">        sname (str): The name of the object to which the pocket will be added.</span>
<span class="sd">        new_cutter_diameter (float): The diameter of the new cutter to be used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">select_all</span><span class="p">(</span><span class="n">action</span><span class="o">=</span><span class="s1">&#39;DESELECT&#39;</span><span class="p">)</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">scene</span>
    <span class="n">mpocket_exists</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">ob</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>  <span class="c1"># delete old medial pocket</span>
        <span class="k">if</span> <span class="n">ob</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;medial_poc&quot;</span><span class="p">):</span>
            <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">bpy</span><span class="o">.</span><span class="n">ops</span><span class="o">.</span><span class="n">object</span><span class="o">.</span><span class="n">delete</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">op</span> <span class="ow">in</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">:</span>  <span class="c1"># verify medial pocket operation exists</span>
        <span class="k">if</span> <span class="n">op</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;MedialPocket&quot;</span><span class="p">:</span>
            <span class="n">mpocket_exists</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">ob</span> <span class="o">=</span> <span class="n">bpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">sname</span><span class="p">]</span>
    <span class="n">ob</span><span class="o">.</span><span class="n">select_set</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">view_layer</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">active</span> <span class="o">=</span> <span class="n">ob</span>
    <span class="n">silhoueteOffset</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="o">-</span><span class="n">new_cutter_diameter</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">)</span>
    <span class="n">bpy</span><span class="o">.</span><span class="n">context</span><span class="o">.</span><span class="n">active_object</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;medial_pocket&#39;</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">mpocket_exists</span><span class="p">:</span>     <span class="c1"># create a pocket operation if it does not exist already</span>
        <span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="o">.</span><span class="n">add</span><span class="p">()</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">o</span><span class="o">.</span><span class="n">object_name</span> <span class="o">=</span> <span class="s1">&#39;medial_pocket&#39;</span>
        <span class="n">s</span><span class="o">.</span><span class="n">cam_active_operation</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">cam_operations</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">o</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;MedialPocket&#39;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">o</span><span class="o">.</span><span class="n">name</span>
        <span class="n">o</span><span class="o">.</span><span class="n">strategy</span> <span class="o">=</span> <span class="s1">&#39;POCKET&#39;</span>
        <span class="n">o</span><span class="o">.</span><span class="n">use_layers</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">estimate_from_model</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">o</span><span class="o">.</span><span class="n">material</span><span class="o">.</span><span class="n">size</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">maxdepth</span>
        <span class="n">o</span><span class="o">.</span><span class="n">minz_from</span> <span class="o">=</span> <span class="s1">&#39;MATERIAL&#39;</span></div>

</pre></div>

                </article>
              

              
              
              
              
                <footer class="prev-next-footer d-print-none">
                  
<div class="prev-next-area">
</div>
                </footer>
              
            </div>
            
            
              
            
          </div>
          <footer class="bd-footer-content">
            
<div class="bd-footer-content__inner container">
  
  <div class="footer-item">
    
<p class="component-author">
By Vilem Novak, Alain Pelletier & Contributors
</p>

  </div>
  
  <div class="footer-item">
    

  <p class="copyright">
    
      Â© Copyright 2024.
      <br/>
    
  </p>

  </div>
  
  <div class="footer-item">
    
  </div>
  
  <div class="footer-item">
    
  </div>
  
</div>
          </footer>
        

      </main>
    </div>
  </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script defer src="../../_static/scripts/bootstrap.js?digest=26a4bc78f4c0ddb94549"></script>
<script defer src="../../_static/scripts/pydata-sphinx-theme.js?digest=26a4bc78f4c0ddb94549"></script>

  <footer class="bd-footer">
  </footer>
  </body>
</html>